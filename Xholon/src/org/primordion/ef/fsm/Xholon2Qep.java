/* Xholon Runtime Framework - executes event-driven & dynamic applications
 * Copyright (C) 2007, 2008 Ken Webb
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
 */

package org.primordion.ef.fsm;

import java.util.Date;

import org.primordion.ef.AbstractXholon2ExternalFormat;
import org.primordion.xholon.base.ISignal;
import org.primordion.xholon.base.IStateMachineEntity;
import org.primordion.xholon.base.IXholon;
import org.primordion.xholon.base.StateMachineEntity;
import org.primordion.xholon.base.Xholon;
import org.primordion.xholon.base.XPath;
import org.primordion.xholon.common.mechanism.CeStateMachineEntity;
import org.primordion.xholon.service.ef.IXholon2ExternalFormat;

/**
 * Export an executing Xholon application as an Java file in Quantum Event Processor (QEP) format.
 * @author <a href="mailto:ken@primordion.com">Ken Webb</a>
 * @see <a href="http://www.primordion.com/Xholon">Xholon Project website</a>
 * @since 0.7 (Created on August 14, 2007)
 * @see http://www.quantum-leaps.com for information about QEP.
 */
public class Xholon2Qep extends AbstractXholon2ExternalFormat implements IXholon2ExternalFormat, CeStateMachineEntity {

  private String qepFileName;
  private String outPath = "./ef/qep/";
  private StringBuilder sb;
  private IXholon root;
  private String modelName;
  private XPath xpath = null;
  private IXholon owningXholon;
  private String owningXholonName;
  private String owningXholonJavaClassName;
  private IXholon topState;
  
  /**
   * Current date and time.
   */
  private Date timeNow;
  private long timeStamp;
  
  /**
   * Constructor.
   */
  public Xholon2Qep() {}
  
	@Override
	public String getVal_String() {
	  return sb.toString();
	}
	
  /**
   * Constructor.
   * @param qepFileName Name of the output QEP file.
   * @param modelName Name of the model.
   * @param root Root of the tree that will be written out.
   */
  public Xholon2Qep(String qepFileName, String modelName, IXholon root) {
    initialize(qepFileName, modelName, root);
  }
  
  /*
   * @see org.primordion.xholon.io.IXholon2Qep#initialize(java.lang.String, java.lang.String, org.primordion.xholon.base.IXholon)
   */
  public boolean initialize(String qepFileName, String modelName, IXholon root) {
    timeNow = new Date();
    timeStamp = timeNow.getTime();
    if (qepFileName == null) {
      this.qepFileName = outPath + root.getXhcName() + "_" + root.getId() + "_" + timeStamp + ".qep";
    }
    else {
      this.qepFileName = qepFileName;
    }
    this.modelName = modelName;
    this.root = root;
    xpath = new XPath();
    return true;
  }

  /*
   * @see org.primordion.xholon.io.IXholon2Qep#writeAll()
   */
  public void writeAll() {
    topState = xpath.evaluate("descendant::StateMachine/descendant::State", root);
    if (topState == null) {return;}
    owningXholon = ((IStateMachineEntity)topState).getOwningXholon();
    owningXholonName = owningXholon.getXhcName();
    owningXholonJavaClassName = owningXholon.getClass().getName(); // get the entire path + name
    if (qepFileName == null) {
      // there is no default file name, so create a file name consistent with this Java class
      qepFileName = "./qep/" + owningXholonName + "QHsm.java";
    }
    sb = new StringBuilder();
    sb.append("");
    sb.append(
      "\n//Automatically generated by Xholon version 0.7, using Xholon2Qep.java\n//"
      + timeNow + "\n//www.primordion.com/Xholon\n"
      + "//See http://www.quantum-leaps.com for information about QEP.\n");
    writeQep();
    writeToTarget(sb.toString(), qepFileName, outPath, root);
  }

  /**
   * Write the qep tag, and the entire structure contained within that element.
   */
  protected void writeQep() {
    sb.append("package "
      + owningXholonJavaClassName.substring(0, owningXholonJavaClassName.lastIndexOf('.'))
      + ";\n\n");
    sb.append("import qep.*;\n");
    sb.append("import " + owningXholonJavaClassName + ";\n");
    owningXholonJavaClassName
      = owningXholonJavaClassName.substring(owningXholonJavaClassName.lastIndexOf('.') + 1);
    sb.append("import org.primordion.xholon.base.IMessage;\n");
    sb.append("import org.primordion.xholon.base.ISignal;\n");
    sb.append("\n");
    sb.append("public class ");
    sb.append(owningXholonName + "QHsm");
    sb.append(" extends QHsm {\n");
    
    // write variables
    // owner of this state machine
    sb.append("protected ");
    sb.append(owningXholonJavaClassName + " smOwner;\n");
    
    // write QEP signals
    // use Java reflection; but not yet sure if these are really needed
    
    // write QEP events
    sb.append("public static class " + owningXholonName + "Evt extends QEvent {\n");
    sb.append("\tpublic IMessage msg;\n");
    sb.append("\tpublic " + owningXholonName + "Evt" + "(int s, IMessage msgArg) {\n");
    sb.append("\t\tsig = s;\n");
    sb.append("\t\tmsg = msgArg;\n");
    sb.append("\t}\n");
    sb.append("}\n");
    
    // write constructor
    sb.append("public " + owningXholonName + "QHsm (" + owningXholonJavaClassName  + " smOwner) {\n");
    sb.append("\tthis.smOwner = smOwner;\n");
    sb.append("}\n");            
    
    // write QEP init()
    sb.append("public void init(QEvent e) {\n");
    sb.append("\tsuper.init_tran(" + topState.getRoleName() + ");\n");
    sb.append("}\n");      
    
    sb.append("\n");
    writeStates();
    sb.append("}\n");
  }
  
  /**
   * Write notes.
   */
  protected void writeNotes() {
    sb.append("//This QEP file has been generated by an early version of the Xholon QEP exporter.\n");
    sb.append("modelName: " + modelName);
  }
  
  /**
   * Write the state machine hierarchy.
   */
  protected void writeStates() {
    sb.append("// States\n");
    if (root.getFirstChild() != null) {
      writeState(root.getFirstChild());
    }
  }
  
  /**
   * Write one state, its transitions, and its child states.
   * @param node The current node in the Xholon composite structure hierarchy.
   */
  protected void writeState(IXholon node) {
    switch(node.getXhcId()) {
    case StateCE:
    case FinalStateCE:
      sb.append("protected QState " + node.getRoleName() + " = new QState() {\n");
      sb.append("\tpublic QState handler(QEvent e) {\n");
      sb.append("\t\tIMessage msg = e.getClass() == " + owningXholonName + "Evt.class ? "
        + "((" + owningXholonName + "Evt)e).msg : null;\n");
      sb.append("\t\tswitch (e.sig) {\n");
      
      // write Q_ENTRY_SIG
      int actId = ((IStateMachineEntity)node).getEntryActivityId();
      if (actId != StateMachineEntity.ACTIVITYID_NONE) {
        sb.append("\t\tcase Q_ENTRY_SIG:\n");
        sb.append("\t\t\tsmOwner.performActivity("
          + actId + ", msg);\n");
        sb.append("\t\t\treturn null;\n");
      }
      
      // write Q_INIT_SIG
      writePseudostateInitial(node);
      
      // write user transitions
      writeTransitions(node); // transitions
      
      // write Q_EXIT_SIG
      actId = ((IStateMachineEntity)node).getExitActivityId();
      if (actId != StateMachineEntity.ACTIVITYID_NONE) {
        sb.append("\t\tcase Q_EXIT_SIG:\n");
        sb.append("\t\t\tsmOwner.performActivity("
          + actId + ", msg);\n");
        sb.append("\t\t\treturn null;\n");
      }
      sb.append("\t\t}\n"); // end switch
      // return the parent state (the super state)
      IXholon parentState = node.getParentNode();
      String parentStateStr = "top"; // default return value
      while (parentState != null) {
        if (parentState.getXhcId() == StateCE) {
          parentStateStr = parentState.getRoleName();
          break;
        }
        else if (parentState.getXhcId() == StateMachineCE) {
          break;
        }
        
        parentState = parentState.getParentNode();
      }
      sb.append("\t\treturn " + parentStateStr + ";\n");
      sb.append("\t}\n");
      sb.append("};\n");
      break;
    case RegionCE:
      break;
    case PseudostateTerminateCE:
      sb.append("protected QState " + node.getRoleName() + " = new QState() {\n");
      sb.append("\tpublic QState handler(QEvent e) {\n");
      // return the parent state (the super state)
      parentState = node.getParentNode();
      parentStateStr = "top"; // default return value
      while (parentState != null) {
        if (parentState.getXhcId() == StateCE) {
          parentStateStr = parentState.getRoleName();
          break;
        }
        else if (parentState.getXhcId() == StateMachineCE) {
          break;
        }
        
        parentState = parentState.getParentNode();
      }
      // parentStateStr may equal null at this point
      // this is OK if
      sb.append("\t\treturn " + parentStateStr + ";\n");
      sb.append("\t}\n");
      sb.append("};\n");
      break;
    default:
      break;
    }
        
    // children
    if (node.getFirstChild() != null) {
      writeState(node.getFirstChild());
    }
    
    // siblings
    if (node.getNextSibling() != null) {
      writeState(node.getNextSibling());
    }
  }
  
  /**
   * Write an initial pseudostate element, if the current state has one.
   * @param stateNode The current state node.
   */
  protected void writePseudostateInitial(IXholon stateNode) {
    IXholon initial = xpath.evaluate("descendant::PseudostateInitial", stateNode);
    if (initial != null) {
      IXholon transition = initial.getPort(0);
      sb.append("\t\tcase Q_INIT_SIG:\n");
      int actId = ((IStateMachineEntity)transition).getActivityId();
      if (actId != StateMachineEntity.ACTIVITYID_NONE) {
        sb.append("\t\t\tsmOwner.performActivity("
          + actId + ", msg);\n");
      }
      sb.append("\t\t\tQ_INIT(");
      IXholon target = transition.getPort(0);
      sb.append(target.getRoleName());
      sb.append(");\n");
      
      sb.append("\t\t\treturn null;\n");
    }
  }
  
  /**
   * Write all transitions that eminate from this state.
   * @param stateNode The current state node.
   */
  protected void writeTransitions(IXholon stateNode) {
    // TODO get actual number of ports to use in for loop
    int lastEvent = ISignal.SIGNAL_DUMMY; // a signal that will never occur
    for (int i = 0; i < StateMachineEntity.getMaxPorts(); i++) {
      IXholon transition = stateNode.getPort(i);
      if (transition != null) {
        lastEvent = writeTransition(transition, lastEvent);
      }
    }
    // write out end of final transition, if there are any transitions
    if (lastEvent != ISignal.SIGNAL_DUMMY) {
      sb.append("\t\t\treturn null;\n");
    }
  }
  
  /**
   * Write one transition.
   * @param transition The current transition node.
   * @param lastEvent 
   */
  protected int writeTransition(IXholon transition, int lastEvent) {
    int event = ISignal.SIGNAL_DUMMY;
    int triggerIx = 0; // trigger index used as input to getTrigger()
    event = ((IStateMachineEntity)transition).getTrigger(triggerIx);
    IXholon triggerNode = xpath.evaluate("Trigger", transition);
    if (event != lastEvent) {
      if (lastEvent != ISignal.SIGNAL_DUMMY) {
        // write out end of last transition, if this is not the first transition
        sb.append("\t\t\treturn null;\n");
      }
      while ((triggerNode != null) && (triggerNode.getXhcId() == TriggerCE)) { // TODO should use constants
        //event = ((IStateMachineEntity)transition).getTrigger(triggerIx);
        // write out case label(s)
        sb.append("\t\tcase ");
        if (triggerNode != null) {
          if (triggerNode.getRoleName().startsWith("ISignal")) {
            sb.append(triggerNode.getRoleName());
          }
          else {
            sb.append(owningXholonJavaClassName + "." + triggerNode.getRoleName());
          }
        }
        else {
          sb.append(Integer.toString(event));
        }
        sb.append(":\n");
        triggerIx++;
        triggerNode = triggerNode.getNextSibling(); // get a possible additional trigger for this transition
      }
    }
    int guardActId = ((IStateMachineEntity)transition).getGuardActivityId();
    if (guardActId != StateMachineEntity.ACTIVITYID_NONE) {
      sb.append("\t\t\t");
      if (event == lastEvent) {
        sb.append("else ");
      }
      sb.append("if (smOwner.performGuard("
        + guardActId + ", msg)) {\n");
      sb.append("\t");
    }
    int actId = ((IStateMachineEntity)transition).getActivityId();
    if (actId != StateMachineEntity.ACTIVITYID_NONE) {
      sb.append("\t\t\tsmOwner.performActivity("
          + actId + ", msg);\n");
    }
    IXholon target = transition.getPort(0);
    if (target != null) {
      if (guardActId != StateMachineEntity.ACTIVITYID_NONE) {
        sb.append("\t" );
      }
      switch (target.getXhcId()) {
      case StateCE:
        sb.append("\t\t\tQ_TRAN(" );
        sb.append(target.getRoleName());
        sb.append(");\n" );
        break;
      case FinalStateCE:
      case PseudostateTerminateCE:
        sb.append("\t\t\tQ_TRAN(" );
        sb.append(target.getRoleName());
        sb.append(");\n" );
        break;
      case PseudostateChoiceCE:
        writeChoices(target);
        break;
      case PseudostateEntryPointCE:
      case PseudostateExitPointCE:
        target = target.getPort(0).getPort(0);
        if (target != null) {
          sb.append("\t\t\tQ_TRAN(" );
          sb.append(target.getRoleName());
          sb.append(");\n" );
        }
        break;
      default:
        break;
      }
    }
    if (guardActId != StateMachineEntity.ACTIVITYID_NONE) {
      sb.append("\t\t\t}\n" );
    }
    return event;
  }
  
  /**
   * Write all transitions from a choice node.
   * @param choiceNode A UML choice node.
   */
  protected void writeChoices(IXholon choiceNode) {
    for (int i = 0; i < StateMachineEntity.getMaxPorts(); i++) {
      IXholon transition = choiceNode.getPort(i);
      if (transition != null) {
        writeChoice(transition, i);
      }
    }
  }
  
  /**
   * Write one transition from a choice node.
   * @param transition A transition leading out of a choice.
   * @param ix An index. If this is not the first transition leading from the choice, then "else" needs to be added.
   */
  protected void writeChoice(IXholon transition, int ix) {
    int guardActId = ((IStateMachineEntity)transition).getGuardActivityId();
    if (guardActId != StateMachineEntity.ACTIVITYID_NONE) {
      sb.append("\t\t\t");
      if (ix > 0) {
        sb.append("else ");
      }
      sb.append("if (smOwner.performGuard("
        + guardActId + ", msg)) {\n");
      sb.append("\t");
    }
    int actId = ((IStateMachineEntity)transition).getActivityId();
    if (actId != StateMachineEntity.ACTIVITYID_NONE) {
      sb.append("\t\t\tsmOwner.performActivity("
          + actId + ", msg);\n");
    }
    IXholon target = transition.getPort(0);
    if (target != null) {
      if (guardActId != StateMachineEntity.ACTIVITYID_NONE) {
        sb.append("\t" );
      }
      sb.append("\t\t\tQ_TRAN(" );
      switch (target.getXhcId()) {
      case StateCE:
        sb.append(target.getRoleName());
        break;
      case FinalStateCE:
      case PseudostateTerminateCE:
        sb.append(target.getRoleName());
        break;
      case PseudostateChoiceCE:
        writeChoices(target);
        break;
      case PseudostateEntryPointCE:
      case PseudostateExitPointCE:
        target = target.getPort(0).getPort(0);
        if (target != null) {
          sb.append(target.getRoleName());
        }
        break;
      default:
        break;
      }
      sb.append(");\n" );
    }
    if (guardActId != StateMachineEntity.ACTIVITYID_NONE) {
      sb.append("\t\t\t}\n" );
    }
  }
}
