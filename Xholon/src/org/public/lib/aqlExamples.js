/**
 * AQL examples
 * source: http://categoricaldata.net/tryaql.html and http://208.113.133.193/
 */

//var aqlExamples = (function () {
(function(root) {
  "use strict";

function getAqlExample(t) {
    var v = t; //.value;

if (v == "Denormalize") { return "typeside Ty = literal { \n	java_types\n		String = \"java.lang.String\"\n	java_constants\n		String = \"return input[0]\"\n}\n\nschema NormalizedSchema = literal : Ty {\n	entities\n		Male \n		Female\n	foreign_keys\n		mother : Male -> Female\n  	attributes\n  		female_name : Female -> String\n  		male_name : Male -> String \n}\n\ninstance NormalizedData = literal : NormalizedSchema {\n	generators\n		Al Bob Charlie : Male\n		Ellie Fran : Female\n	equations\n		Al.male_name = Albert \n		Al.mother = Ellie\n		\n		Bob.male_name = George\n		Bob.mother = Ellie\n		\n		Charlie.male_name = Charles	\n		Charlie.mother = Fran\n\n		Ellie.female_name = Elaine\n		Fran.female_name = Francine\n}\n\nschema DeNormalizedSchema = literal : Ty {\n	imports\n		NormalizedSchema\n	attributes\n		mother_name : Male -> String\n  	observation_equations\n  		forall m:Male. mother_name(m) = female_name(mother(m))\n}\n\ninstance DeNormalizedData = literal : DeNormalizedSchema {\n	imports\n		NormalizedData\n}\n" }

else if (v == "Delta") { return "typeside Ty = literal {\n	types\n		int\n	constants\n		\"100\" \"150\" \"200\" \"250\" \"300\" : int\n	java_types\n		string = \"java.lang.String\"\n	java_constants\n		string = \"return input[0]\"\n}\n\nschema C = literal : Ty {\n 	entities \n		T1 T2\n 	attributes\n		t1_ssn t1_first t1_last : T1 -> string\n		t2_first t2_last : T2 -> string\n		t2_salary : T2 -> int\n}\n\nschema D = literal : Ty {\n 	entities \n		T\n 	attributes\n		ssn0 first0 last0 : T -> string\n		salary0 : T -> int\n}\n\nmapping F = literal : C -> D {\n 	entities \n		T1 -> T\n		T2 -> T\n 	attributes\n		t1_ssn    -> lambda x:T. ssn0(x)\n		t1_first  -> lambda x:T. first0(x)\n		t2_first  -> lambda x:T. first0(x)\n		t1_last   -> lambda x:T. last0(x)\n		t2_last   -> lambda x:T. last0(x)\n		t2_salary -> lambda x:T. salary0(x)\n} \n\ninstance J = literal : D {\n	generators \n		XF667 XF891 XF221 : T\n	equations\n		XF667.ssn0 = \"115-234\" XF891.ssn0 = \"112-988\" XF221.ssn0 = \"198-887\"\n//		XF667.first0 = Bob XF891.first0 = Sue XF221.first0 = Alice\n		XF667.last0 = Smith XF891.last0 = Smith XF221.last0 = Jones\n		XF667.salary0 = 250 XF891.salary0 = 300 XF221.salary0 = 100\n}  \n\ninstance deltaFJ = delta F J\n\ninstance J0 = literal : D {\n generators \n	XF22 aXF66 XF89  xxx : T \n equations\n	aXF66.ssn0 = \"115-234\" XF89.ssn0 = \"112-988\" XF22.ssn0 = \"198-887\"\n	/* aXF66.first0 = Bob XF89.first0 = Sue */ XF22.first0 = Alice\n	aXF66.last0 = Smith XF89.last0 = Smith XF22.last0 = Jones\n	aXF66.salary0 = 250 XF89.salary0 = 300 XF22.salary0 = 100\n}\n\ntransform h = literal : J -> J0 {\n generators\n	 XF667 -> aXF66 \n	 XF891 -> XF89 \n	 XF221 -> XF22\n}\n\ntransform h0 = delta F h\n\ninstance sigmadeltaFJ = sigma F deltaFJ\n\ntransform u = counit F J\n" }

else if (v == "Employees") { return "typeside Ty = literal { \n	types\n 		string \n 		nat\n	constants\n 		Al Akin Bob Bo Carl Cork Dan Dunn Math CS : string\n 		zero : nat\n 	functions 		\n	 	succ		: nat -> nat\n	 	plus		: nat, nat -> nat\n	equations  \n	 	forall x. plus(zero, x) = x\n	 	forall x, y. plus(succ(x),y) = succ(plus(x,y))\n	options\n		prover = completion\n}\n\nschema S = literal : Ty {\n	entities\n		Employee \n		Department\n	foreign_keys\n		manager   : Employee -> Employee\n		worksIn   : Employee -> Department\n		secretary : Department -> Employee\n	path_equations \n		manager.worksIn = worksIn\n  		secretary.worksIn = Department\n  	attributes\n  		first last	: Employee -> string\n     	age			: Employee -> nat\n     	cummulative_age: Employee -> nat\n     	name 		: Department -> string\n     observation_equations\n     	forall e. cummulative_age(e) = plus(age(e), age(manager(e)))\n	options\n		prover = completion\n}\n\ninstance I = literal : S {\n	generators \n		a b c : Employee\n		m s : Department\n	equations \n		first(a) = Al\n		first(b) = Bob  last(b) = Bo\n		first(c) = Carl \n		name(m)  = Math name(s) = CS\n		age(a) = age(c) \n		manager(a) = b manager(b) = b manager(c) = c\n		worksIn(a) = m worksIn(b) = m worksIn(c) = s\n		secretary(s) = c secretary(m) = b \n		secretary(worksIn(a)) = manager(a)\n		worksIn(a) = worksIn(manager(a))\n		age(a) = zero.succ.succ \n		age(manager(a)) = zero.succ\n	options\n		prover = completion\n		completion_precedence = \"zero a b c m s Al Akin Bob Bo Carl Cork Dan Dunn Math CS first last name age manager worksIn secretary succ plus\"\n} \n\n/////////////////////////////////////////////////////////////////\n\ntypeside TyJava = literal { \n	java_types\n		string = \"java.lang.String\"\n		nat = \"java.lang.Integer\"\n	java_constants\n		string = \"return input[0]\"\n		nat = \"return java.lang.Integer.parseInt(input[0])\"\n	java_functions\n		plus : nat,nat -> nat = \"return (input[0] + input[1]).intValue()\"\n}\n\nschema SJava = literal : TyJava {\n	entities\n		Employee \n		Department\n	foreign_keys\n		manager   : Employee -> Employee\n		worksIn   : Employee -> Department\n		secretary : Department -> Employee\n	path_equations \n		manager.worksIn = worksIn\n  		secretary.worksIn = Department\n  		manager.manager = manager\n  	attributes\n  		first last	: Employee -> string\n     	age			: Employee -> nat\n     	cummulative_age: Employee -> nat\n     	name 		: Department -> string\n     observation_equations\n     	forall e. cummulative_age(e) = plus(age(e), age(manager(e)))\n}\n\ninstance IJava = literal : SJava {\n	generators \n		a b c : Employee\n		m s : Department\n	equations \n		first(a) = Al\n		first(b) = Bob  last(b) = Bo\n		first(c) = Carl \n		name(m)  = Math name(s) = CS\n		age(a) = age(c) \n		manager(a) = b manager(b) = b manager(c) = c\n		worksIn(a) = m worksIn(b) = m worksIn(c) = s\n		secretary(s) = c secretary(m) = b \n		secretary(worksIn(a)) = manager(a)\n		worksIn(a) = worksIn(manager(a))\n		age(a) = \"2\" \n		age(manager(a)) = \"1\"\n}\n" }

else if (v == "Finance Colim") { return "//Example courtesy of Jee Chung\n\ntypeside Ty = literal {\n	java_types	\n		Integer = \"java.lang.Integer\"\n		String = \"java.lang.String\"\n		Double = \"java.lang.Double\"\n		Boolean = \"java.lang.String\" \n		Date = \"java.lang.String\"\n//		Date = \"java.util.Date\" alternative type for dates\n	java_constants\n		Integer = \"return java.lang.Integer.parseInt(input[0]);\"\n		String = \"return input[0]\"\n		Double = \"return java.lang.Double.parseDouble(input[0])\"\n		Boolean = \"return input[0]\" \n		Date = \"return input[0]\"\n//		Date = \"return (new java.text.SimpleDateFormat(\\\"m/d/yyyy\\\").parse(input[0]));\"\n	java_functions\n		keygen : Integer,Integer,Integer -> Integer = \"return (2^input[0] * 3^input[1] * 5^input[2])\"\n}\n\n		\n////////////////////////////////////////////////////////////////////////\n//Input schemas and instances separately\n////////////////////////////////////////////////////////////////////////\n\n//compile time input\nschema Client = literal : Ty {\n	entities\n		client\n	attributes\n		client_id : client -> Integer\n		client_name : client -> String\n		client_description : client -> String\n} \n\n//runtime input\ninstance ClientInstance = literal : Client {\n     generators \n     	cc1 cc2 cc3 : client   	\n     multi_equations //alternative, less verbose syntax\n     	client_id -> {cc1 \"1\", cc2 \"2\", cc3 \"3\"}\n     	client_name -> {cc1 Tom, cc2 Dick, cc3 Harry}\n     	client_description -> {cc1 \"Tom Client\", cc2 \"Dick Client\", cc3 \"Harry Client\"}\n} \n//instance ClientInstance = import_csv \"/Users/ryan/github/fql/examples/finance/Client\" : Client \n\n////////////////////////////////////////////////////////////////////////\n\n//compile time input\nschema Portfolio = literal : Ty {\n	entities\n		strategy \n		portfolio\n	foreign_keys			\n		portfolio_strategy : portfolio -> strategy\n		portfolio_parent_portfolio : portfolio -> portfolio //added\n	path_equations\n		portfolio_parent_portfolio.portfolio_parent_portfolio = portfolio_parent_portfolio //added required\n	attributes			\n		strategy_id : strategy -> Integer\n		strategy_name : strategy -> String\n		strategy_description : strategy -> String\n		portfolio_id : portfolio -> Integer\n		portfolio_name : portfolio -> String\n		portfolio_description : portfolio -> String\n		portfolio_client_id : portfolio -> Integer\n		portfolio_strategy_id : portfolio -> Integer\n		portfolio_parent_portfolio_id : portfolio -> Integer //added \n	observation_equations\n		forall p. p.portfolio_strategy.strategy_id = p.portfolio_strategy_id\n		forall p. p.portfolio_parent_portfolio.portfolio_id = p.portfolio_parent_portfolio_id //added\n} \n\n//runtime input\ninstance PortfolioInstance = literal : Portfolio {\n     generators \n     	ps1 ps2 ps3 : strategy //not having ps2 here is really weird because it means this instance has nulls in it \n     	pp1 pp2 pp3 : portfolio\n     equations\n		pp1.portfolio_parent_portfolio_id = \"1\" pp1.portfolio_parent_portfolio = pp1 //pp1 is parent of itself\n		pp2.portfolio_parent_portfolio_id = \"2\" pp2.portfolio_parent_portfolio = pp2 //pp2 is parent of itself\n		pp3.portfolio_parent_portfolio_id = \"2\" pp3.portfolio_parent_portfolio = pp2 //pp3's parent is pp2\n     \n		ps1.strategy_id = \"1\" ps1.strategy_name = Strat1 ps1.strategy_description = Strategy1 \n		ps2.strategy_id = \"2\" ps2.strategy_name = Strat2 ps2.strategy_description = Strategy2 \n		ps3.strategy_id = \"3\" ps3.strategy_name = Strat3 ps3.strategy_description = Strategy3 \n		pp1.portfolio_id = \"1\" pp1.portfolio_name = Port1 pp1.portfolio_description = Portfolio1 pp1.portfolio_client_id = \"1\" pp1.portfolio_strategy_id = \"2\" pp1.portfolio_strategy = ps2\n		pp2.portfolio_id = \"2\" pp2.portfolio_name = Port2 pp2.portfolio_description = Portfolio2 pp2.portfolio_client_id = \"2\" pp2.portfolio_strategy_id = \"2\" pp2.portfolio_strategy = ps2\n		pp3.portfolio_id = \"3\" pp3.portfolio_name = Port3 pp3.portfolio_description = Portfolio3 pp3.portfolio_client_id = \"2\" pp3.portfolio_strategy_id = \"1\" pp3.portfolio_strategy = ps1\n} \n//instance PortfolioInstance = import_csv \"/Users/ryan/github/fql/examples/finance/Portfolio\" : Portfolio\n\n////////////////////////////////////////////////////////////////////////\n\n//compile time input		\nschema Ref = literal : Ty {\n	entities\n		country \n		currency \n		asset \n		strategy\n	foreign_keys\n		currency_country : currency -> country\n		asset_strategy : asset -> strategy\n	attributes	\n		country_id : country -> Integer\n		country_code : country -> String\n		country_name : country -> String\n		asset_id : asset -> Integer\n		asset_name : asset -> String\n		asset_description : asset -> String\n		asset_strategy_id : asset -> Integer\n		strategy_id : strategy -> Integer\n		strategy_name : strategy -> String\n		strategy_description : strategy -> String\n		currency_id : currency -> Integer\n		currency_code : currency -> String\n		currency_name : currency -> String\n		currency_country_id : currency -> Integer\n	observation_equations	\n		forall c. c.currency_country.country_id = c.currency_country_id\n		forall a. a.asset_strategy.strategy_id = a.asset_strategy_id\n} 	\n\n//runtime input\ninstance RefInstance = literal : Ref {\n     generators \n     	rcty1 rcty2 rcty3 rcty4 rcty5 rcty6 : country \n		rcur1 rcur2 rcur3 : currency \n		ra1 ra2 ra3 ra4 ra5 ra6 ra7 ra8 ra9 ra10 : asset \n		rs1 rs2 rs3 rs4 rs5 : strategy\n     equations	\n 		rcty1.country_id = \"1\" rcty1.country_code = AU rcty1.country_name = Australia \n 		rcty2.country_id = \"2\" rcty2.country_code = CH rcty2.country_name = Switzerland \n 		rcty3.country_id = \"3\" rcty3.country_code = CN rcty3.country_name = China \n 		rcty4.country_id = \"4\" rcty4.country_code = EU rcty4.country_name = \"European Union\" \n 		rcty5.country_id = \"5\" rcty5.country_code = JP rcty5.country_name = Japan \n 		rcty6.country_id = \"6\" rcty6.country_code = US rcty6.country_name = \"United States of America\" \n 		rcur1.currency_id = \"1\" rcur1.currency_code = USD rcur1.currency_name = \"US Dollar\" rcur1.currency_country_id  = \"6\" rcur1.currency_country = rcty6 \n		rcur2.currency_id = \"2\" rcur2.currency_code = EUR rcur2.currency_name = \"Euro\" rcur2.currency_country_id  = \"4\" rcur2.currency_country = rcty4 \n		rcur3.currency_id = \"3\" rcur3.currency_code = JPY rcur3.currency_name = \"Japanese Yen\" rcur3.currency_country_id  = \"5\" rcur3.currency_country = rcty5 	 		 		\n		ra1.asset_id = \"1\" ra1.asset_name = A1 ra1.asset_description = Asset1 ra1.asset_strategy_id = \"1\" ra1.asset_strategy = rs1 \n		ra2.asset_id = \"2\" ra2.asset_name = A2 ra2.asset_description = Asset2 ra2.asset_strategy_id = \"3\" ra2.asset_strategy = rs3\n		ra3.asset_id = \"3\" ra3.asset_name = A3 ra3.asset_description = Asset3 ra3.asset_strategy_id = \"2\" ra3.asset_strategy = rs2		 \n		ra4.asset_id = \"4\" ra4.asset_name = A4 ra4.asset_description = Asset4 ra4.asset_strategy_id = \"4\" ra4.asset_strategy = rs4\n		ra5.asset_id = \"5\" ra5.asset_name = A5 ra5.asset_description = Asset5 ra5.asset_strategy_id = \"5\" ra5.asset_strategy = rs5\n		ra6.asset_id = \"6\" ra6.asset_name = A6 ra6.asset_description = Asset6 ra6.asset_strategy_id = \"4\" ra6.asset_strategy = rs4\n		ra7.asset_id = \"7\" ra7.asset_name = A7 ra7.asset_description = Asset7 ra7.asset_strategy_id = \"4\" ra7.asset_strategy = rs4\n		ra8.asset_id = \"8\" ra8.asset_name = A8 ra8.asset_description = Asset8 ra8.asset_strategy_id = \"5\" ra8.asset_strategy = rs5\n		ra9.asset_id = \"9\" ra9.asset_name = A9 ra9.asset_description = Asset9 ra9.asset_strategy_id = \"3\" ra9.asset_strategy = rs3\n		ra10.asset_id = \"10\" ra10.asset_name = A10 ra10.asset_description = Asset10 ra10.asset_strategy_id = \"1\" ra10.asset_strategy = rs1\n		rs1.strategy_id = \"1\" rs1.strategy_name = Strat1 rs1.strategy_description = Strategy1 \n		rs2.strategy_id = \"2\" rs2.strategy_name = Strat2 rs2.strategy_description = Strategy2 \n		rs3.strategy_id = \"3\" rs3.strategy_name = Strat3 rs3.strategy_description = Strategy3 \n		rs4.strategy_id = \"4\" rs4.strategy_name = Strat4 rs4.strategy_description = Strategy4 \n		rs5.strategy_id = \"5\" rs5.strategy_name = Strat5 rs5.strategy_description = Strategy5\n} \n//instance RefInstance = import_csv \"/Users/ryan/github/fql/examples/finance/Ref\" : Ref\n\n////////////////////////////////////////////////////////////////////////\n\n//compile time input		\nschema Trans = literal : Ty {\n	entities\n		asset \n		currency \n		transaction\n	foreign_keys\n		transaction_asset : transaction -> asset\n		transaction_currency : transaction -> currency\n	attributes	\n		asset_id : asset -> Integer\n		asset_name : asset -> String\n		asset_description : asset -> String\n		currency_id : currency -> Integer\n		currency_code : currency -> String\n		currency_name : currency -> String\n		transaction_id : transaction -> Integer\n		transaction_date : transaction -> Date	// added as a new column\n		transaction_asset_id : transaction -> Integer\n		transaction_portfolio_id : transaction -> Integer\n		transaction_buy_sell_ind : transaction -> Boolean\n		transaction_quantity : transaction -> Integer\n		transaction_price : transaction -> Double\n		transaction_currency_id : transaction -> Integer\n	observation_equations	\n		forall t. t.transaction_asset.asset_id = t.transaction_asset_id\n		forall t. t.transaction_currency.currency_id = t.transaction_currency_id\n} \n\n//runtime input\ninstance TransInstance = literal : Trans {\n     generators \n		ta1 ta3 ta5 ta7 ta9 : asset \n		tc1 tc2 tc3 : currency \n		tt1 tt2 tt3 tt4 tt5 tt6 : transaction\n     equations\n		ta1.asset_id = \"1\" ta1.asset_name = A1 ta1.asset_description = Asset1 \n		ta3.asset_id = \"3\" ta3.asset_name = A3 ta3.asset_description = Asset3 \n		ta5.asset_id = \"5\" ta5.asset_name = A5 ta5.asset_description = Asset5 \n		ta7.asset_id = \"7\" ta7.asset_name = A7 ta7.asset_description = Asset7 \n		ta9.asset_id = \"9\" ta9.asset_name = A9 ta9.asset_description = Asset9 \n		tc1.currency_id = \"1\" tc1.currency_code = USD tc1.currency_name = \"US Dollar\" \n		tc2.currency_id = \"2\" tc2.currency_code = EUR tc2.currency_name = Euro \n		tc3.currency_id = \"3\" tc3.currency_code = JPY tc3.currency_name = \"Japanese Yen\" \n		tt1.transaction_id = \"1\" tt1.transaction_asset_id = \"1\" tt1.transaction_asset = ta1 tt1.transaction_portfolio_id = \"1\" tt1.transaction_buy_sell_ind = buy tt1.transaction_quantity = \"200\" tt1.transaction_price = \"5.51\" tt1.transaction_currency_id  = \"2\" tt1.transaction_currency = tc2 tt1.transaction_date = \"1/1/2011\"\n		tt2.transaction_id = \"2\" tt2.transaction_asset_id = \"1\" tt2.transaction_asset = ta1 tt2.transaction_portfolio_id = \"1\" tt2.transaction_buy_sell_ind = sell tt2.transaction_quantity = \"100\" tt2.transaction_price = \"5.5\" tt2.transaction_currency_id  = \"2\" tt2.transaction_currency = tc2 tt2.transaction_date = \"6/1/2011\"\n		tt3.transaction_id = \"3\" tt3.transaction_asset_id = \"3\" tt3.transaction_asset = ta3 tt3.transaction_portfolio_id = \"2\" tt3.transaction_buy_sell_ind = buy tt3.transaction_quantity = \"150\" tt3.transaction_price = \"2.5\" tt3.transaction_currency_id  = \"1\" tt3.transaction_currency = tc1 tt3.transaction_date = \"9/1/2013\"\n		tt4.transaction_id = \"4\" tt4.transaction_asset_id = \"3\" tt4.transaction_asset = ta3 tt4.transaction_portfolio_id = \"2\" tt4.transaction_buy_sell_ind = sell tt4.transaction_quantity = \"150\" tt4.transaction_price = \"3.5\" tt4.transaction_currency_id  = \"1\" tt4.transaction_currency = tc1 tt4.transaction_date = \"3/1/2014\"\n		tt5.transaction_id = \"5\" tt5.transaction_asset_id = \"5\" tt5.transaction_asset = ta5 tt5.transaction_portfolio_id = \"3\" tt5.transaction_buy_sell_ind = buy tt5.transaction_quantity = \"200\" tt5.transaction_price = \"1.6\" tt5.transaction_currency_id  = \"3\" tt5.transaction_currency = tc3 tt5.transaction_date = \"2/1/2013\"\n		tt6.transaction_id = \"6\" tt6.transaction_asset_id = \"5\" tt6.transaction_asset = ta5 tt6.transaction_portfolio_id = \"3\" tt6.transaction_buy_sell_ind = sell tt6.transaction_quantity = \"100\" tt6.transaction_price = \"1.5\" tt6.transaction_currency_id  = \"3\" tt6.transaction_currency = tc3 tt6.transaction_date = \"7/1/2013\"\n} \n//instance TransInstance = import_csv \"/Users/ryan/github/fql/examples/finance/Trans\" : Trans\n\n////////////////////////////////////////////////////////////////////////\n\n//compile time input\nschema HoldPos = literal : Ty {\n	entities\n		client \n		holding \n		position\n	foreign_keys	\n		holding_client : holding -> client\n		position_client : position -> client\n	attributes	\n		client_no : client -> Integer	// new name\n		client_nm : client -> String	// new name\n		client_desc : client -> String	// new name\n		holding_id : holding -> Integer\n		holding_client_no : holding -> Integer	// new name\n		holding_portfolio_id : holding -> Integer\n		holding_asset_id : holding -> Integer\n		holding_quantity : holding -> Integer\n		holding_purchase_date : holding -> Date\n		holding_purchase_price : holding -> Double\n		holding_currency_code : holding -> String	// switched from _id to _code\n		holding_begin_date : holding -> Date	// new attribute\n		holding_end_date : holding -> Date		// new attribute\n		position_id : position -> Integer\n		position_client_no : position -> Integer	// new name\n		position_asset_id : position -> Integer\n		position_quantity : position -> Integer\n		position_current_value : position -> Integer\n		position_current_value_currency_code : position -> String	// switched from _id to _code\n		position_cost_basis : position -> Integer\n		position_cost_basis_currency_code : position -> String	// switched from _id to _code\n	observation_equations	\n		forall h. h.holding_client.client_no = h.holding_client_no\n		forall p. p.position_client.client_no = p.position_client_no\n} \n\n//runtime input\ninstance HoldPosInstance = literal : HoldPos {\n     generators \n  		hpc1 hpc2 : client \n		hph1 hph2 hph3 hph4 hph5 : holding \n		hpp1 hpp2 : position\n     equations\n		// below lines were also updated to reflect the new column names in HoldPos.client\n		hpc1.client_no  = \"1\" hpc1.client_nm = Tom hpc1.client_desc = \"Tom Client\" \n		hpc2.client_no  = \"2\" hpc2.client_nm = Dick hpc2.client_desc = \"Dick Client\" \n\n		// inserted two holding instances with IDs 2 & 5 ID values for all instances except 1 were adjusted\n		hph1.holding_id = \"1\" hph1.holding_client_no = \"1\" hph1.holding_client = hpc1 hph1.holding_portfolio_id = \"1\" hph1.holding_asset_id = \"1\" hph1.holding_quantity = \"200\" hph1.holding_purchase_date = \"1/1/2011\" hph1.holding_purchase_price = \"5.51\" hph1.holding_currency_code = \"EUR\" hph1.holding_begin_date = \"1/1/2011\" hph1.holding_end_date = \"6/1/2011\"\n		hph2.holding_id = \"2\" hph2.holding_client_no = \"1\" hph2.holding_client = hpc1 hph2.holding_portfolio_id = \"1\" hph2.holding_asset_id = \"1\" hph2.holding_quantity = \"100\" hph2.holding_purchase_date = \"1/1/2011\" hph2.holding_purchase_price = \"5.51\" hph2.holding_currency_code = \"EUR\" hph2.holding_begin_date = \"6/1/2011\"\n		hph3.holding_id = \"3\" hph3.holding_client_no = \"2\" hph3.holding_client = hpc2 hph3.holding_portfolio_id = \"3\" hph3.holding_asset_id = \"3\" hph3.holding_quantity = \"150\" hph3.holding_purchase_date = \"9/1/2013\" hph3.holding_purchase_price = \"2.5\"  hph3.holding_currency_code = \"USD\" hph3.holding_begin_date = \"9/1/2013\" hph3.holding_end_date = \"3/1/2014\"\n		hph4.holding_id = \"4\" hph4.holding_client_no = \"2\" hph4.holding_client = hpc2 hph4.holding_portfolio_id = \"3\" hph4.holding_asset_id = \"5\" hph4.holding_quantity = \"200\" hph4.holding_purchase_date = \"2/1/2013\" hph4.holding_purchase_price = \"1.6\"  hph4.holding_currency_code = \"JPY\" hph4.holding_begin_date = \"2/1/2013\" hph4.holding_end_date = \"7/1/2013\"\n		hph5.holding_id = \"5\" hph5.holding_client_no = \"2\" hph5.holding_client = hpc2 hph5.holding_portfolio_id = \"3\" hph5.holding_asset_id = \"5\" hph5.holding_quantity = \"100\" hph5.holding_purchase_date = \"2/1/2013\" hph5.holding_purchase_price = \"1.6\"  hph5.holding_currency_code = \"JPY\" hph5.holding_begin_date = \"7/1/2013\"\n\n		hpp1.position_id = \"1\" hpp1.position_client_no = \"1\" hpp1.position_client = hpc1 hpp1.position_asset_id = \"1\" hpp1.position_quantity = \"100\" hpp1.position_current_value = \"550\" hpp1.position_current_value_currency_code = \"EUR\" hpp1.position_cost_basis = \"551\" hpp1.position_cost_basis_currency_code = \"EUR\"		\n		hpp2.position_id = \"2\" hpp2.position_client_no = \"2\" hpp2.position_client = hpc2 hpp2.position_asset_id = \"5\" hpp2.position_quantity = \"100\" hpp2.position_current_value = \"170\" hpp2.position_current_value_currency_code = \"JPY\" hpp2.position_cost_basis = \"160\" hpp2.position_cost_basis_currency_code = \"JPY\"\n} \n\n//nulls in CSV data are indicated with csv_null_string\n//instance HoldPosInstance = import_csv \"/Users/ryan/github/fql/examples/finance/HoldPos\" : HoldPos {\n//	options\n//		csv_null_string = \"NULL\" \n//}	\n////////////////////////////////////////////////////////////////////////\n//Linkages between input schemas and instances\n////////////////////////////////////////////////////////////////////////\n//todo: remove name and description attributes from overlaps?\n////////////////////////////////////////////////////////////////////////\n\n//compile time input\nschema ClientHoldPosLinkage = literal : Ty {\n	entities\n		client\n	attributes\n		client_id : client -> Integer\n		client_name : client -> String\n		client_description : client -> String\n} \n\n//compile time input\nmapping ClientHoldPosLinkageToClient = literal : ClientHoldPosLinkage -> Client {\n	entities\n		client -> client\n	attributes\n		client_id -> lambda x. x.client_id\n		client_name -> lambda x. x.client_name\n		client_description -> lambda x. x.client_description\n} \n\n//compile time input\nmapping ClientHoldPosLinkageToHoldPos = literal : ClientHoldPosLinkage -> HoldPos {\n	entities\n		client -> client\n	attributes\n		client_id -> lambda x. client_no(x)             // updated to reflect the new name\n		client_name -> lambda x. client_nm(x)         // updated to reflect the new name\n		client_description -> lambda x. client_desc(x)  // updated to reflect the new name\n} \n\n//runtime input\ninstance ClientHoldPosLinkageInstance = literal : ClientHoldPosLinkage {\n	generators\n		tom dick : client\n	equations\n		tom.client_id = \"1\" \n		tom.client_name = Tom\n		tom.client_description = \"Tom Client\"\n		dick.client_id = \"2\" \n		dick.client_name = Dick\n		dick.client_description = \"Dick Client\"\n} \n//instance ClientHoldPosLinkageInstance = import_csv \"/Users/ryan/github/fql/examples/finance/ClientHoldPos\" : ClientHoldPosLinkage\n\n//computed at compile time\ninstance Sigma_ClientHoldPosLinkageToClient_ClientHoldPosLinkageInstance = sigma ClientHoldPosLinkageToClient ClientHoldPosLinkageInstance\n\n//runtime input\ntransform ClientHoldPosLinkageInstanceToClientInstance = literal : Sigma_ClientHoldPosLinkageToClient_ClientHoldPosLinkageInstance -> ClientInstance {\n	generators\n		tom -> cc1\n		dick -> cc2\n} \n//transform ClientHoldPosLinkageInstanceToClientInstance = import_csv \"/Users/ryan/github/fql/examples/finance/ClientHoldPos/toClient.csv\" : Sigma_ClientHoldPosLinkageToClient_ClientHoldPosLinkageInstance -> ClientInstance\n\n//computed at compile time\ninstance Sigma_ClientHoldPosLinkageToHoldPos_ClientHoldPosLinkageInstance = sigma ClientHoldPosLinkageToHoldPos ClientHoldPosLinkageInstance\n\n//runtime input\ntransform ClientHoldPosLinkageInstanceToHoldPosInstance = literal : Sigma_ClientHoldPosLinkageToHoldPos_ClientHoldPosLinkageInstance -> HoldPosInstance {\n	generators\n		tom -> hpc1\n		dick -> hpc2\n} \n//transform ClientHoldPosLinkageInstanceToHoldPosInstance = import_csv \"/Users/ryan/github/fql/examples/finance/ClientHoldPos/toHoldPos.csv\" : Sigma_ClientHoldPosLinkageToHoldPos_ClientHoldPosLinkageInstance -> HoldPosInstance\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n//compile time input\nschema PortfolioRefLinkage = literal : Ty {\n	entities\n		strategy\n	attributes\n		strategy_id : strategy -> Integer\n		strategy_name : strategy -> String\n		strategy_description : strategy -> String\n} \n\n//compile time input\nmapping PortfolioRefLinkageToPortfolio = literal  : PortfolioRefLinkage -> Portfolio {\n	entities\n		strategy -> strategy\n	attributes\n		strategy_id -> lambda c. c.strategy_id\n		strategy_name -> lambda c. c.strategy_name\n		strategy_description -> lambda c. c.strategy_description\n}\n\n//compile time input\nmapping PortfolioRefLinkageToRef = literal : PortfolioRefLinkage -> Ref {\n	entities\n		strategy -> strategy\n	attributes\n		strategy_id -> lambda c. c.strategy_id\n		strategy_name -> lambda c. c.strategy_name\n		strategy_description -> lambda c. c.strategy_description	\n} \n\n//runtime input\ninstance PortfolioRefLinkageInstance = literal : PortfolioRefLinkage {\n	generators\n		strat1 /* strat2 */ strat3 : strategy //no link for strat2 deliberately\n	equations\n		strat1.strategy_id = \"1\" strat1.strategy_name = Strat1 strat1.strategy_description = Strategy1\n//		strat2.strategy_id = \"2\" strat2.strategy_name = Strat2 strat2.strategy_description = Strategy2\n		strat3.strategy_id = \"3\" strat3.strategy_name = Strat3 strat3.strategy_description = Strategy3\n} \n//instance PortfolioRefLinkageInstance = import_csv \"/Users/ryan/github/fql/examples/finance/PortfolioRef\" : PortfolioRefLinkage\n\n\n//computed at compile time\ninstance Sigma_PortfolioRefLinkageToPortfolio_PortfolioRefLinkageInstance = sigma PortfolioRefLinkageToPortfolio PortfolioRefLinkageInstance \n\n//runtime input\ntransform PortfolioRefLinkageInstanceToPortfolioInstance = literal : Sigma_PortfolioRefLinkageToPortfolio_PortfolioRefLinkageInstance -> PortfolioInstance {\n	generators\n		strat1 -> ps1 \n		//strat2 -> ps2\n		strat3 -> ps3\n} \n//transform PortfolioRefLinkageInstanceToPortfolioInstance = import_csv \"/Users/ryan/github/fql/examples/finance/PortfolioRef/toPortfolio.csv\" : Sigma_PortfolioRefLinkageToPortfolio_PortfolioRefLinkageInstance -> PortfolioInstance\n\n//computed at compile time\ninstance Sigma_PortfolioRefLinkageToRef_PortfolioRefLinkageInstance = sigma PortfolioRefLinkageToRef PortfolioRefLinkageInstance \n\n//runtime input\ntransform PortfolioRefLinkageInstanceToRefInstance = literal : Sigma_PortfolioRefLinkageToRef_PortfolioRefLinkageInstance -> RefInstance {\n	generators\n		strat1 -> rs1\n	//	strat2 -> rs2 \n		strat3 -> rs3\n} \n//transform PortfolioRefLinkageInstanceToRefInstance = import_csv \"/Users/ryan/github/fql/examples/finance/PortfolioRef/toRef.csv\" : Sigma_PortfolioRefLinkageToRef_PortfolioRefLinkageInstance -> RefInstance\n\n////////////////////////////////////////////////////////////////////////\n\n//compile time input\nschema RefTransLinkage = literal : Ty {\n	entities\n		currency \n		asset\n	attributes\n		currency_id : currency -> Integer\n		currency_code : currency -> String\n		currency_name : currency -> String\n		asset_id : asset -> Integer\n		asset_name : asset -> String\n		asset_description : asset -> String\n} \n\n//compile time input		\nmapping RefTransLinkageToRef = literal : RefTransLinkage -> Ref	 {\n	entities\n		currency -> currency\n		asset -> asset\n	attributes\n		currency_id -> lambda c. c.currency_id\n		currency_code -> lambda c. c.currency_code\n		currency_name -> lambda c. c.currency_name	\n		asset_id -> lambda c. c.asset_id\n		asset_name -> lambda a. a.asset_name\n		asset_description -> lambda a. a.asset_description\n} \n\n//compile time input				\nmapping RefTransLinkageToTrans = literal : RefTransLinkage -> Trans {\n	entities\n		currency -> currency\n		asset -> asset\n	attributes\n		currency_id -> lambda c. c.currency_id\n		currency_code -> lambda c. c.currency_code\n		currency_name -> lambda c. c.currency_name\n		asset_id -> lambda c. c.asset_id	\n		asset_name -> lambda a. a.asset_name\n		asset_description -> lambda a. a.asset_description\n}\n\n//runtime input\ninstance RefTransLinkageInstance = literal : RefTransLinkage {\n	generators\n		usd eur jpy : currency \n		one three five seven nine : asset\n	equations	\n		usd.currency_id = \"1\" usd.currency_code = USD usd.currency_name = \"US Dollar\"  \n		eur.currency_id = \"2\" eur.currency_code = EUR eur.currency_name = \"Euro\" \n		jpy.currency_id = \"3\" jpy.currency_code = JPY jpy.currency_name = \"Japanese Yen\" 	 		 		\n	\n		one.asset_id = \"1\" one.asset_name = A1 one.asset_description = Asset1 \n		three.asset_id = \"3\" three.asset_name = A3 three.asset_description = Asset3 \n		five.asset_id = \"5\" five.asset_name = A5 five.asset_description = Asset5 \n		seven.asset_id = \"7\" seven.asset_name = A7 seven.asset_description = Asset7 \n		nine.asset_id = \"9\" nine.asset_name = A9 nine.asset_description = Asset9\n} \n//instance RefTransLinkageInstance = import_csv \"/Users/ryan/github/fql/examples/finance/RefTrans\" : RefTransLinkage \n\n\n//computed at compile time\ninstance Sigma_RefTransLinkageToRef_RefTransLinkageInstance = sigma RefTransLinkageToRef RefTransLinkageInstance \n\n//runtime input\ntransform RefTransLinkageInstanceToRefInstance = literal : Sigma_RefTransLinkageToRef_RefTransLinkageInstance -> RefInstance {\n	generators\n		usd -> rcur1\n		eur -> rcur2\n		jpy -> rcur3\n		one -> ra1 \n		three -> ra3 \n		five -> ra5 \n		seven -> ra7\n		nine -> ra9\n} \n//transform RefTransLinkageInstanceToRefInstance = import_csv \"/Users/ryan/github/fql/examples/finance/RefTrans/toRef.csv\" : Sigma_RefTransLinkageToRef_RefTransLinkageInstance -> RefInstance\n\n//computed at compile time\ninstance Sigma_RefTransLinkageToTrans_RefTransLinkageInstance = sigma RefTransLinkageToTrans RefTransLinkageInstance\n\n//runtime input\ntransform RefTransLinkageInstanceToTransInstance = literal : Sigma_RefTransLinkageToTrans_RefTransLinkageInstance -> TransInstance {\n	generators\n		usd -> tc1\n		eur -> tc2\n		jpy -> tc3\n		one -> ta1\n		three -> ta3\n		five -> ta5\n		seven -> ta7\n		nine -> ta9\n} \n//transform RefTransLinkageInstanceToTransInstance = import_csv \"/Users/ryan/github/fql/examples/finance/RefTrans/toTrans.csv\" : Sigma_RefTransLinkageToTrans_RefTransLinkageInstance -> TransInstance \n\n\n////////////////////////////////////////////////////////////////////////\n//Schema Colimit computation\n////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////\n\n//simplified colimit schema done by hand. \n//compile time input\nschema Colimit = literal : Ty {\n	imports\n		Client Ref Trans Portfolio HoldPos\n	path_equations\n		client_no = client_id	\n	observation_equations\n		forall x. x.client_nm = x.client_name\n		forall x. x.client_desc = x.client_description\n	options \n		program_allow_nontermination_unsafe=true\n} \n\n//since we used a custom\n//colimit schema we have to give the mappings into Colimit explicitly. \n\n//the client mapping is just textual inclusion\nmapping ClientIdentityMapping = id Client\n\n//compile time input / computed at compile time\nmapping ClientToColimit = literal : Client -> Colimit  {\n	entities\n		client -> client\n	attributes\n		client_id -> lambda x. client_no(x)\n		client_name -> lambda x. client_nm(x)\n		client_description -> lambda x. client_desc(x)	\n} \n\nmapping RefIdentityMapping = id Ref\n\n//compile time input / computed at compile time\nmapping RefToColimit = literal : Ref -> Colimit  {\n	imports \n		RefIdentityMapping\n} \n\nmapping TransIdentityMapping = id Trans\n\n//compile time input / computed at compile time\nmapping TransToColimit = literal : Trans -> Colimit  {\n	imports \n		TransIdentityMapping\n} \n\nmapping PortfolioIdentityMapping = id Portfolio\n\n//compile time input / computed at compile time\nmapping PortfolioToColimit = literal : Portfolio -> Colimit  {\n	imports \n		PortfolioIdentityMapping\n} \n\nmapping HoldPosIdentityMapping = id HoldPos\n\n//compile time input / computed at compile time\n//here we translate into Client, to make for an easier colimit later\nmapping HoldPosToColimit = literal : HoldPos -> Colimit  {\n	imports \n		HoldPosIdentityMapping\n} \n\nmapping RefTransLinkageIdentityMapping = id RefTransLinkage\n\n//compile time input / computed at compile time\nmapping RefTransLinkageToColimit = literal : RefTransLinkage -> Colimit {\n	imports \n		RefTransLinkageIdentityMapping\n} \n\nmapping PortfolioRefLinkageIdentityMapping = id PortfolioRefLinkage\n\n//compile time input / computed at compile time\nmapping PortfolioRefLinkageToColimit = literal : PortfolioRefLinkage -> Colimit {\n	imports \n		PortfolioRefLinkageIdentityMapping\n} \n\nmapping ClientHoldPosLinkageIdentityMapping = id ClientHoldPosLinkage\n\nmapping ClientHoldPosLinkageToColimit = literal : ClientHoldPosLinkage -> Colimit {\n	entities\n		client -> client\n	attributes\n		client_id -> lambda x. client_no(x)\n		client_name -> lambda x. client_nm(x)\n		client_description -> lambda x. client_desc(x)	\n} \n\n////////////////////////////////////////////////////////////////////////\n//Instance Colimit computation\n////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////\n\n//we use the mappings from the colimit of schemas to push all our\n//data and data-level linkages onto the colimit schema then we do a colimit of instances.\n\n\ninstance ClientInstanceOnColimit = sigma ClientToColimit ClientInstance\ninstance RefInstanceOnColimit = sigma RefToColimit RefInstance\ninstance TransInstanceOnColimit = sigma TransToColimit TransInstance\ninstance PortfolioInstanceOnColimit = sigma PortfolioToColimit PortfolioInstance \ninstance HoldPosInstanceOnColimit = sigma HoldPosToColimit HoldPosInstance\ninstance RefTransLinkageInstanceOnColimit = sigma RefTransLinkageToColimit RefTransLinkageInstance\ninstance PortfolioRefLinkageInstanceOnColimit = sigma PortfolioRefLinkageToColimit PortfolioRefLinkageInstance\ninstance ClientHoldPosLinkageInstanceOnColimit = sigma ClientHoldPosLinkageToColimit ClientHoldPosLinkageInstance\n\ntransform RefTransLinkageToTransOnColimit = sigma TransToColimit RefTransLinkageInstanceToTransInstance \ntransform RefTransLinkageToRefOnColimit = sigma RefToColimit RefTransLinkageInstanceToRefInstance \ntransform PortfolioRefLinkageToPortfolioOnColimit = sigma PortfolioToColimit PortfolioRefLinkageInstanceToPortfolioInstance \ntransform PortfolioRefLinkageToRefOnColimit = sigma RefToColimit PortfolioRefLinkageInstanceToRefInstance \ntransform ClientHoldPosLinkageToClientOnColimit = sigma ClientToColimit ClientHoldPosLinkageInstanceToClientInstance \ntransform ClientHoldPosLinkageToHoldPosOnColimit = sigma HoldPosToColimit ClientHoldPosLinkageInstanceToHoldPosInstance\n\n\ngraph Shape = literal {\n	nodes \n		c \n		h \n		p \n		r \n		t \n		rt\n		pr\n		ch\n	edges\n		rtt : rt -> t\n		rtr : rt -> r\n		prp : pr -> p\n		prr : pr -> r\n		chc : ch -> c\n		chh : ch -> h\n}\n\ninstance ColimitInstance = colimit Shape Colimit  {\n	nodes \n		c -> ClientInstanceOnColimit\n		h -> HoldPosInstanceOnColimit\n		p -> PortfolioInstanceOnColimit\n		r -> RefInstanceOnColimit\n		t -> TransInstanceOnColimit\n		rt -> RefTransLinkageInstanceOnColimit\n		pr -> PortfolioRefLinkageInstanceOnColimit\n		ch -> ClientHoldPosLinkageInstanceOnColimit\n	edges\n		rtt -> RefTransLinkageToTransOnColimit\n		rtr -> RefTransLinkageToRefOnColimit\n		prp -> PortfolioRefLinkageToPortfolioOnColimit\n		prr -> PortfolioRefLinkageToRefOnColimit\n		chc -> ClientHoldPosLinkageToClientOnColimit\n		chh -> ClientHoldPosLinkageToHoldPosOnColimit\n}\n\n////////////////////////////////////////////////////////////////////////\n//Desired Target Schema translated from asset-mgmt-er.pdf\n////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////\n\n//compile time input\nschema Target = literal : Ty {\n	entities\n		currency //Trans Ref\n		strategy //Portfolio Ref\n		asset //Trans Ref\n		transaction //Trans\n		client //HoldPos\n		position //HoldPos\n		country //Ref\n		portfolioholding //NEW\n		portfolio //Portfolio \n		holding //HoldPos\n	\n	foreign_keys\n		portfolio_strategy : portfolio -> strategy //Portfolio\n		portfolio_parent_portfolio : portfolio -> portfolio //Added for cyclic FK on Portfolio.portfolio.  ryan also added the cyclic fk to \n		\n		position_client : position -> client //HoldPos\n		position_asset : position -> asset //NEW\n		position_current_value_currency : position -> currency //NEW\n		position_cost_basis_currency : position -> currency //NEW\n		\n		asset_strategy : asset -> strategy //Ref\n		\n		currency_country : currency -> country //Ref \n		\n		transaction_currency : transaction -> currency //Trans \n		transaction_asset : transaction -> asset //Trans \n		transaction_portfolio : transaction -> portfolio //NEW\n\n		holding_currency : holding -> currency //NEW\n		// added below we might have missed in defining the \"target\" schema we had used in \"er_pushout.opl\"\n		// ryan concurs.  todo: meaningless ID discussion \n		holding_asset : holding -> asset\n\n		// below is supposed to be the analog of the \"junction table\" between client portfolio & holding\n		// but in looking at the holding table above seems redundant. Why is that?\n		portfolioholding_holding : portfolioholding -> holding //NEW\n		portfolioholding_client : portfolioholding -> client //NEW \n		portfolioholding_portfolio : portfolioholding -> portfolio //NEW\n	\n	path_equations\n		//todo: revisit scenario using parent . client = client rather than parent . parent = parent\n		portfolio_parent_portfolio.portfolio_parent_portfolio = portfolio_parent_portfolio\n\n	attributes\n		currency_code : currency -> String //Trans Ref\n		currency_name : currency -> String //Trans Ref\n		currency_id : currency -> Integer //Ref\n		currency_country_id : currency -> Integer //Ref\n\n		country_code : country -> String //Ref\n		country_name : country -> String //Ref\n		country_id : country -> Integer //Ref		\n\n		asset_id : asset -> Integer //Trans Ref\n		asset_description : asset -> String //Trans Ref\n		asset_name : asset -> String //Trans Ref\n		asset_strategy_id : asset -> Integer //Ref\n				\n		strategy_name : strategy -> String //Ref Portfolio\n		strategy_description : strategy -> String //Ref Portfolio\n		strategy_id : strategy -> Integer //Ref Portfolio		\n\n		portfolio_name : portfolio -> String //Portfolio\n		portfolio_description : portfolio -> String //Portfolio\n		portfolio_id : portfolio -> Integer //Portfolio\n		portfolio_strategy_id : portfolio -> Integer //Portfolio\n		portfolio_parent_portfolio_id : portfolio -> Integer	//Portfolio ADDED\n		\n		position_quantity : position -> Integer //HoldPos\n		position_current_value : position -> Integer //HoldPos\n		position_cost_basis : position -> Integer //HoldPos\n		position_id : position -> Integer //HoldPos\n		position_client_id : position -> Integer //HoldPos\n		position_asset_id : position -> Integer //HoldPos\n		position_current_value_currency_id : position -> Integer // HoldPos \n		position_cost_basis_currency_id : position -> Integer // HoldPos		\n\n		holding_id : holding -> Integer //HoldPos				\n		holding_asset_id : holding -> Integer //HoldPos\n		holding_currency_id : holding -> Integer //HoldPos\n		holding_purchase_price : holding -> Double //HoldPos\n		holding_quantity : holding -> Integer //HoldPos //HoldPos\n		holding_purchase_date : holding -> Date //HoldPos		\n		holding_begin_date : holding -> Date //HoldPos new attribute\n		holding_end_date : holding -> Date //HoldPos new attribute\n\n		client_description : client -> String //HoldPos\n		client_name : client -> String //HoldPos\n		client_id : client -> Integer //HoldPos		\n\n		transaction_id : transaction -> Integer //Trans\n		transaction_asset_id : transaction -> Integer //Trans\n		transaction_buy_sell_ind : transaction -> Boolean //Trans\n		transaction_quantity : transaction -> Integer //Trans\n		transaction_price : transaction -> Double //Trans\n		transaction_currency_id : transaction -> Integer //Trans			\n		transaction_portfolio_id : transaction -> Integer //Trans\n		transaction_date : transaction -> Date	//added as a new column\n\n		portfolioholding_id : portfolioholding -> Integer //NEW todo: talk to Jee about this\n		portfolioholding_holding_id : portfolioholding -> Integer //NEW\n		portfolioholding_client_id : portfolioholding -> Integer //NEW\n		portfolioholding_portfolio_id : portfolioholding -> Integer //NEW\n	\n	observation_equations\n		forall p. p.portfolio_parent_portfolio.portfolio_id = p.portfolio_parent_portfolio_id //added\n		forall p. p.portfolio_strategy.strategy_id = p.portfolio_strategy_id\n		forall a. a.asset_strategy.strategy_id = a.asset_strategy_id	\n		forall p. p.position_client.client_id = p.position_client_id\n		forall c. c.currency_country.country_id = c.currency_country_id\n		forall t. t.transaction_currency.currency_id = t.transaction_currency_id\n		forall t. t.transaction_asset.asset_id = t.transaction_asset_id\n		forall p. p.portfolioholding_holding.holding_id = p.portfolioholding_holding_id\n		forall p. p.portfolioholding_client.client_id = p.portfolioholding_client_id	\n		forall p. p.portfolioholding_portfolio.portfolio_id = p.portfolioholding_portfolio_id					\n		forall p. p.position_asset.asset_id = p.position_asset_id\n		forall h. h.holding_currency.currency_id = h.holding_currency_id\n		forall t. t.transaction_portfolio.portfolio_id = t.transaction_portfolio_id\n		forall p. p.position_current_value_currency.currency_id = p.position_current_value_currency_id\n		forall p. p.position_cost_basis_currency.currency_id = p.position_cost_basis_currency_id	\n}\n\n\n////////////////////////////////////////////////////////////////////////\n//An uber-flower to migrate from Colim to Target\n////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////\n		\nquery ETL = literal : Colimit -> Target {\n entities\n \n	//identity\n	currency -> {from c:currency\n		 return currency_code -> c.currency_code\n			currency_name -> c.currency_name\n			currency_id -> c.currency_id\n			currency_country_id -> c.currency_country_id\n	options \n		program_allow_nontermination_unsafe=true\n	} \n\n\n	//identity\n	strategy -> {from s:strategy\n		 return strategy_name -> s.strategy_name\n		 	strategy_description -> s.strategy_description\n		 	strategy_id -> s.strategy_id\n	options \n		program_allow_nontermination_unsafe=true\n	}\n\n	//identity\n	asset -> {from a:asset\n		 return asset_id -> a.asset_id\n		 	asset_description -> a.asset_description\n		 	asset_name -> a.asset_name\n		 	asset_strategy_id -> a.asset_strategy_id\n	options \n		program_allow_nontermination_unsafe=true\n	} \n\n	//identity\n	client -> {from c:client\n		 return client_description -> c.client_description \n			client_name -> c.client_name\n			client_id -> c.client_id\n	options \n		program_allow_nontermination_unsafe=true\n	} \n\n	//identity\n	country -> {from c:country\n		 return country_code -> c.country_code\n		 	country_name -> c.country_name\n		 	country_id -> c.country_id\n	options \n		program_allow_nontermination_unsafe=true\n	} \n\n	//not identity\n	transaction -> {from t:transaction p:portfolio c:client c1:client\n		 where t.transaction_portfolio_id = p.portfolio_id\n		 return transaction_id -> t.transaction_id \n			transaction_asset_id -> t.transaction_asset_id \n			transaction_buy_sell_ind -> t.transaction_buy_sell_ind \n			transaction_quantity -> t.transaction_quantity\n			transaction_price -> t.transaction_price \n			transaction_date -> t.transaction_date\n			transaction_currency_id -> t.transaction_currency_id 			\n			transaction_portfolio_id -> t.transaction_portfolio_id\n	options \n		program_allow_nontermination_unsafe=true\n	}\n\n	//not identity\n	position -> {from p:position a:asset cv:currency cb:currency\n		 where p.position_asset_id = a.asset_id\n		 	p.position_current_value_currency_code = cv.currency_code\n		 	p.position_cost_basis_currency_code = cb.currency_code\n		 return position_quantity -> p.position_quantity\n		 	position_current_value -> p.position_current_value\n		 	position_cost_basis -> p.position_cost_basis\n		 	position_id -> p.position_id \n		 	position_client_id -> p.position_client_no\n		 	position_asset_id -> p.position_asset_id\n		 	position_current_value_currency_id -> cv.currency_id\n		 	position_cost_basis_currency_id -> cb.currency_id\n	options \n		program_allow_nontermination_unsafe=true\n		} \n\n	//not identity\n	portfolio -> {from p:portfolio\n		 return portfolio_parent_portfolio_id -> p.portfolio_parent_portfolio_id //added\n		 	portfolio_name -> p.portfolio_name\n		 	portfolio_description -> p.portfolio_description\n		 	portfolio_id -> p.portfolio_id\n		 	portfolio_strategy_id -> p.portfolio_strategy_id\n	options \n		program_allow_nontermination_unsafe=true\n	} \n\n	//not identity\n	holding -> {from h:holding c:currency a:asset\n		 where a.asset_id = h.holding_asset_id\n		 	h.holding_currency_code = c.currency_code\n		 return holding_id -> h.holding_id			\n			holding_asset_id -> h.holding_asset_id\n			holding_currency_id -> c.currency_id 			\n			holding_purchase_price -> h.holding_purchase_price \n			holding_quantity -> h.holding_quantity \n			holding_purchase_date -> h.holding_purchase_date \n			holding_begin_date -> h.holding_begin_date \n			holding_end_date -> h.holding_end_date\n	options \n		program_allow_nontermination_unsafe=true\n	} \n   \n	//not identity \n	portfolioholding -> {from h:holding p:portfolio cur:currency c1:client a:asset\n		 where a.asset_id = h.holding_asset_id\n		     p.portfolio_parent_portfolio.portfolio_client_id = c1.client_id\n		 	c1.client_id = h.holding_client.client_id\n		 	h.holding_currency_code = cur.currency_code\n		 	p.portfolio_client_id = h.holding_client.client_id\n		 	h.holding_portfolio_id = p.portfolio_id\n		 return portfolioholding_id -> keygen(h.holding_id, h.holding_client.client_id, p.portfolio_id) //added by ryan\n		 	portfolioholding_holding_id -> h.holding_id\n			portfolioholding_client_id -> c1.client_id\n			portfolioholding_portfolio_id -> p.portfolio_id\n		options\n			program_allow_nontermination_unsafe=true\n		} \n\n foreign_keys\n\n 	currency_country -> {c -> c.currency_country} 		\n	asset_strategy -> {s -> a.asset_strategy} 		\n	transaction_currency -> {c -> t.transaction_currency} \n	transaction_asset -> {a -> t.transaction_asset} \n	transaction_portfolio -> {p -> p} 	//NEW	\n	position_client -> {c -> p.position_client} \n	position_asset -> {a -> a}  //NEW\n	position_current_value_currency -> {c -> cv}  //NEW\n	position_cost_basis_currency -> {c -> cb}  //NEW\n	portfolio_parent_portfolio -> {p -> p.portfolio_parent_portfolio}  //added\n	portfolio_strategy -> {s -> p.portfolio_strategy} \n	holding_asset -> {a -> a} \n	holding_currency -> {c -> c}  //NEW\n	portfolioholding_holding -> {h -> h c -> cur a -> a}\n	portfolioholding_client -> {c -> h.holding_client}  \n	portfolioholding_portfolio -> {p -> p} 	\n\n} \n\ninstance Output = eval ETL ColimitInstance\n\n////////////////////////////////////////////////////////////////////////\n// Target schema A - cyclic FK version (on the Portfolio entity)\n////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////\n\nschema CycTarget = literal : Ty {\n	entities\n		client\n		country\n		currency\n		strategy\n		asset\n		portfolio\n		transaction\n		clientposition\n		clientportfolioholding\n\n	foreign_keys\n		currency_country : currency -> country\n\n		asset_strategy : asset -> strategy\n\n		portfolio_strategy : portfolio -> strategy\n		portfolio_parent_portfolio : portfolio -> portfolio // for cyclic FK on portfolio\n\n		transaction_currency : transaction -> currency\n		transaction_asset : transaction -> asset\n		transaction_portfolio : transaction -> portfolio\n\n		clientposition_client : clientposition -> client\n		clientposition_asset : clientposition -> asset\n\n		clientportfolioholding_asset : clientportfolioholding -> asset\n		clientportfolioholding_client : clientportfolioholding -> client\n		clientportfolioholding_portfolio : clientportfolioholding -> portfolio\n\n	path_equations\n		//added by ryan\n		portfolio_parent_portfolio.portfolio_parent_portfolio = portfolio_parent_portfolio \n\n	attributes\n		client_id : client -> Integer\n		client_name : client -> String\n		client_description : client -> String\n\n		country_id : country -> Integer\n		country_code : country -> String\n		country_name : country -> String\n\n		currency_id : currency -> Integer\n		currency_code : currency -> String\n		currency_name : currency -> String\n		currency_country_id : currency -> Integer\n\n		asset_id : asset -> Integer\n		asset_name : asset -> String\n		asset_description : asset -> String\n		asset_strategy_id : asset -> Integer\n\n		strategy_id : strategy -> Integer\n		strategy_name : strategy -> String\n		strategy_description : strategy -> String\n\n		portfolio_id : portfolio -> Integer\n		portfolio_name : portfolio -> String\n		portfolio_description : portfolio -> String\n		portfolio_strategy_id : portfolio -> Integer\n		portfolio_parent_portfolio_id : portfolio -> Integer // for cyclic FK on portfolio\n\n		transaction_id : transaction -> Integer\n		transaction_date : transaction -> Date\n		transaction_portfolio_id : transaction -> Integer\n		transaction_portfolio_name : transaction -> String // intentionally added for query convenience\n		transaction_asset_id : transaction -> Integer\n		transaction_asset_name : transaction -> String // intentionally added for query convenience\n		transaction_buy_sell_ind : transaction -> Boolean\n		transaction_quantity : transaction -> Integer\n		transaction_price : transaction -> Double\n		transaction_currency_id : transaction -> Integer\n\n		clientposition_id : clientposition -> Integer\n		clientposition_begin_date : clientposition -> Date\n		clientposition_end_date : clientposition -> Date\n		clientposition_client_id : clientposition -> Integer\n		clientposition_client_name : clientposition -> String // intentionally added for query convenience\n		clientposition_asset_id : clientposition -> Integer\n		clientposition_asset_name : clientposition -> String // intentionally added for query convenience\n		clientposition_quantity : clientposition -> Integer\n		clientposition_current_value : clientposition -> Integer\n		clientposition_current_value_currency_code : clientposition -> String // intentionally code instead of id for query convenience\n\n		clientportfolioholding_id : clientportfolioholding -> Integer\n		clientportfolioholding_begin_date : clientportfolioholding -> Date\n		clientportfolioholding_end_date : clientportfolioholding -> Date\n		clientportfolioholding_portfolio_id : clientportfolioholding -> Integer\n		clientportfolioholding_portfolio_name : clientportfolioholding -> String // intentionally added for query convenience\n		clientportfolioholding_client_id : clientportfolioholding -> Integer\n		clientportfolioholding_client_name : clientportfolioholding -> String // intentionally added for query convenience\n		clientportfolioholding_asset_id : clientportfolioholding -> Integer\n		clientportfolioholding_asset_name : clientportfolioholding -> String // intentionally added for query convenience\n		clientportfolioholding_quantity : clientportfolioholding -> Integer\n		clientportfolioholding_purchase_date : clientportfolioholding -> Date\n		clientportfolioholding_purchase_price : clientportfolioholding -> Double\n		clientportfolioholding_currency_code : clientportfolioholding -> String // intentionally code instead of id for query convenience\n	\n	observation_equations\n		forall c. c.currency_country.country_id = c.currency_country_id\n\n		forall a. a.asset_strategy.strategy_id = a.asset_strategy_id\n\n		forall p. p.portfolio_strategy.strategy_id = p.portfolio_strategy_id\n		forall p. p.portfolio_parent_portfolio.portfolio_id = p.portfolio_parent_portfolio_id\n\n		forall t. t.transaction_currency.currency_id = t.transaction_currency_id\n		forall t. t.transaction_asset.asset_id = t.transaction_asset_id\n		forall t. t.transaction_portfolio.portfolio_id = t.transaction_portfolio_id\n\n		forall p. p.clientposition_asset.asset_id = p.clientposition_asset_id\n		forall p. p.clientposition_client.client_id = p.clientposition_client_id\n\n		forall p. p.clientportfolioholding_asset.asset_id = p.clientportfolioholding_asset_id\n		forall p. p.clientportfolioholding_client.client_id = p.clientportfolioholding_client_id\n		forall p. p.clientportfolioholding_portfolio.portfolio_id = p.clientportfolioholding_portfolio_id\n\n} \n\n\nquery ETL_Cyc = literal : Target -> CycTarget {\n entities\n 	\n	client -> {from c:client\n		 return client_id -> c.client_id\n			client_name -> c.client_name\n			client_description -> c.client_description\n	} \n\n	country -> {from c:country\n		 return country_id -> c.country_id\n			country_code -> c.country_code\n			country_name -> c.country_name\n		 } \n\n	currency -> {from c:currency\n		 return currency_id -> c.currency_id\n			currency_code -> c.currency_code\n			currency_name -> c.currency_name\n			currency_country_id -> c.currency_country_id\n	} \n\n	asset -> {from a:asset\n		 return asset_id -> a.asset_id\n			asset_name -> a.asset_name\n			asset_description -> a.asset_description\n			asset_strategy_id -> a.asset_strategy_id\n	} \n\n	strategy -> {from s:strategy\n		 return strategy_id -> s.strategy_id\n			strategy_name -> s.strategy_name\n			strategy_description -> s.strategy_description\n	}\n\n	portfolio -> {from p:portfolio\n		 return portfolio_id -> p.portfolio_id\n			portfolio_name -> p.portfolio_name\n			portfolio_description -> p.portfolio_description\n			portfolio_strategy_id -> p.portfolio_strategy_id\n			portfolio_parent_portfolio_id -> p.portfolio_parent_portfolio_id\n	} \n\n	transaction -> {from t:transaction\n		 return transaction_id -> t.transaction_id\n			transaction_date -> t.transaction_date\n			transaction_portfolio_id -> t.transaction_portfolio_id\n			transaction_portfolio_name -> t.transaction_portfolio.portfolio_name\n			transaction_asset_id -> t.transaction_asset_id\n			transaction_asset_name -> t.transaction_asset.asset_name\n			transaction_buy_sell_ind -> t.transaction_buy_sell_ind\n			transaction_quantity -> t.transaction_quantity\n			transaction_price -> t.transaction_price\n			transaction_currency_id -> t.transaction_currency_id\n		} \n\n	clientposition -> {from p:position\n		 return clientposition_id -> p.position_id\n			clientposition_begin_date -> \"1/1/2011\" // fake this for now source doesn't have it\n			clientposition_end_date -> \"1/1/2011\" // fake this for now source doesn't have it\n			clientposition_client_id -> p.position_client.client_id\n			clientposition_client_name -> p.position_client.client_name\n			clientposition_asset_id -> p.position_asset.asset_id\n			clientposition_asset_name -> p.position_asset.asset_name\n			clientposition_quantity -> p.position_quantity\n			clientposition_current_value -> p.position_current_value\n			clientposition_current_value_currency_code -> p.position_current_value_currency.currency_code\n	} \n\n	clientportfolioholding -> {from ph:portfolioholding\n		 return clientportfolioholding_id -> ph.portfolioholding_holding.holding_id\n			clientportfolioholding_begin_date -> ph.portfolioholding_holding.holding_begin_date\n			clientportfolioholding_end_date -> ph.portfolioholding_holding.holding_end_date\n			clientportfolioholding_asset_id -> ph.portfolioholding_holding.holding_asset.asset_id\n			clientportfolioholding_asset_name -> ph.portfolioholding_holding.holding_asset.asset_name\n			clientportfolioholding_purchase_price -> ph.portfolioholding_holding.holding_purchase_price\n			clientportfolioholding_quantity -> ph.portfolioholding_holding.holding_quantity\n			clientportfolioholding_purchase_date -> ph.portfolioholding_holding.holding_purchase_date\n			clientportfolioholding_client_id -> ph.portfolioholding_client.client_id\n			clientportfolioholding_client_name -> ph.portfolioholding_client.client_name\n			clientportfolioholding_portfolio_id -> ph.portfolioholding_portfolio.portfolio_id\n			clientportfolioholding_portfolio_name -> ph.portfolioholding_portfolio.portfolio_name\n			clientportfolioholding_currency_code -> ph.portfolioholding_holding.holding_currency.currency_code\n	} \n\n foreign_keys\n\n	clientportfolioholding_client -> {c -> ph.portfolioholding_client} \n 	clientportfolioholding_asset -> {a -> ph.portfolioholding_holding.holding_asset} \n	clientportfolioholding_portfolio -> {p -> ph.portfolioholding_portfolio} \n	clientposition_client -> {c -> p.position_client} \n	clientposition_asset -> {a -> p.position_asset} \n	transaction_currency -> {c -> t.transaction_currency} \n	transaction_asset -> {a -> t.transaction_asset} \n	transaction_portfolio -> {p -> t.transaction_portfolio} \n	portfolio_parent_portfolio -> {p -> p.portfolio_parent_portfolio} \n	portfolio_strategy -> {s->p.portfolio_strategy} \n	asset_strategy -> {s -> a.asset_strategy} \n	currency_country -> {c -> c.currency_country} \n	\n\n} \n\ninstance OutputCyc = eval ETL_Cyc Output \n \ninstance OutputCycDistinct = distinct OutputCyc\n\n//pragma emit1 = export_csv_instance OutputCycDistinct \"/Users/ryan/Desktop/OutputCycDistinct/\"\n//pragma emit2 = export_csv_transform RefTransLinkageToTransOnColimit \"/Users/ryan/Desktop/RefTransLinkageToTransOnColimit.csv\"" }

else if (v == "Foreign Keys") { return "typeside Ty = empty\n\nschema University = literal : Ty {\n	entities\n		Professor Student Department\n 	foreign_keys\n		worksIn    : Professor -> Department\n		majoringIn : Student -> Department	\n} \n\nschema AdvisorMatches = literal : Ty {\n	imports\n		University\n	entities\n		Match\n 	foreign_keys\n		studentOf : Match -> Student\n		professorOf : Match -> Professor\n	path_equations\n		studentOf.majoringIn = professorOf.worksIn\n} \n\nquery findMatches = literal : University -> AdvisorMatches {\n entities\n	Department -> {from dept:Department}\n		\n	Professor -> {from prof:Professor}\n\n	Student -> {from stu:Student}\n\n/* When \n * \n *   where p.worksIn = s.majoringIn \n *   \n * is commented out the query is rejected: \n *   \n *   Error in query findMatches: \n *     Target equation v.studentOf.majoringIn = v.professorOf.worksIn not respected: \n *       transforms to s.majoringIn = p.worksIn, which is not provable in the sub-query for Match.\n */  Match -> {from p:Professor s:Student \n		     where p.worksIn = s.majoringIn} \n\nforeign_keys		 	   \n\n	majoringIn -> {dept -> stu.majoringIn}\n	\n	worksIn -> {dept -> prof.worksIn}\n	\n	professorOf -> {prof -> p}\n	\n	studentOf -> {stu -> s}\n\n/* Disabling the equation validator will cause a runtime error when this query is executed:\n * \n *   Error in instance MatchesForUnivX : Algebra does not satisfy equation  \n *     forall v. v.studentOf.majoringIn = v.professorOf.worksIn \n *       on ID <Match p:[Euler],s:[Kleene]>\n */ /* options\n	    dont_validate_unsafe=true */\n\n} \n\n \ninstance UniversityOfX = literal : University {\n	generators\n		Gauss Church Euler : Professor\n		Riemann Turing Kleene : Student\n		math cs : Department\n	multi_equations\n		worksIn -> {Gauss math, Church cs, Euler math}\n		majoringIn -> {Riemann math, Turing cs, Kleene cs}		\n}\n\ninstance MatchesForUnivX = eval findMatches UniversityOfX\n" }

else if (v == "Joinless") { return "typeside Ty = literal { \n	java_types\n		String = \"java.lang.String\"\n	java_constants\n		String = \"return input[0]\"\n}\n\nschema Schools = literal : Ty {\n	entities \n		Person\n		School\n		Dept\n	foreign_keys\n	     instituteOf : Person -> School \n	     deptOf      : Person -> Dept\n	     biggestDept : School -> Dept\n	attributes\n		lastName    : Person -> String\n	     schoolName  : School -> String\n	     deptName    : Dept   -> String\n}\n\ninstance BostonSchools = literal : Schools {\n	generators \n		ryan david adam greg gregory jason : Person\n	     harvard mit : School\n	     math cs : Dept\n	multi_equations \n		lastName -> {ryan Wisnesky, david Spivak, adam Chlipala, greg Morrisett, gregory Malecha, jason Gross}\n		schoolName -> {harvard Harvard, mit MIT}\n		deptName -> {math Mathematics, cs CompSci}\n		instituteOf -> {ryan harvard, david mit, adam mit, greg harvard, gregory harvard, jason mit}\n		deptOf -> {ryan math, david math, adam cs, greg cs, gregory cs, jason cs}\n		biggestDept -> {harvard math, mit cs}\n}\n\n\nschema Person = literal : Ty {\n	entities \n		Person\n	attributes\n		lastName   : Person -> String\n		schoolName : Person -> String\n}\n\n//Find all the people whose school's biggest department is Mathematics\nquery BiggestDeptIsMathQuery = literal : Schools -> Person {\n	entities\n		Person -> {from   p:Person\n				 where  p.instituteOf.biggestDept.deptName = Mathematics\n				 return lastName -> p.lastName \n			  		   schoolName -> p.instituteOf.schoolName}\n} \n\ninstance BiggestDeptIsMathInBoston = eval BiggestDeptIsMathQuery BostonSchools\n" }

else if (v == "Outer Join") { return "//Outer joins using java's Optional class\n\ntypeside Ty = literal {\n	java_types\n		String = \"java.lang.String\"\n		Nat = \"java.lang.Integer\"\n		Bool = \"java.lang.Boolean\"\n		NullableNat = \"java.util.Optional\"\n	java_constants\n		String = \"return input[0]\"\n		Nat = \"return java.lang.Integer.parseInt(input[0])\"\n		Bool = \"return java.lang.Boolean.parseBool(input[0])\"\n		NullableNat = \"return java.lang.Integer.parseInt(input[0])\"\n	java_functions\n		null : -> NullableNat = \"return java.util.Optional.empty()\"\n		inNat : Nat -> NullableNat = \"return java.util.Optional.of(input[0])\"\n		eqNat : Nat, Nat -> Bool = \"return (input[0].equals(input[1]))\"\n		ifNat : Bool, NullableNat, NullableNat -> NullableNat = \n		  \"if (input[0]) { return input[1]; } else { return input[2]; }\"\n}		  \n\nschema S = literal : Ty {\n	entities\n		A B\n	attributes\n		Aname : A -> String\n		Bname : B -> String\n		Aid : A -> Nat\n		Bid : B -> Nat\n}\n\nschema T = literal : Ty {\n	entities\n		C\n	attributes\n		CAname : C -> String\n		CBname : C -> String\n		Cid : C -> NullableNat\n} \n\nquery OuterJoin = literal : S -> T {\n 	entities \n	 	C  -> {from a:A b:B\n 			  return Cid -> ifNat(eqNat(a.Aid, b.Bid), inNat(a.Aid), null)\n 			         CAname -> a.Aname\n 		     	    CBname -> b.Bname\n 		  	} \n}  \n\ninstance I = literal : S {\n	generators\n		a1 a2 : A\n		b2 b3 : B\n	equations\n		a1.Aname = alice a1.Aid = \"1\"\n		a2.Aname = bob a2.Aid = \"2\"\n		b2.Bname = charlie b2.Bid = \"2\"\n		b3.Bname = dave b3.Bid = \"3\"\n} \n\ninstance J = eval OuterJoin I\n" }

else if (v == "Pharma Colim") { return "//Example courtesy of Peter Gates\n\ntypeside Type = literal {\n	java_types	\n		dom = \"java.lang.Object\"\n	java_constants\n		dom = \"return input[0]\"\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nschema S = literal : Type {\n	entities\n		O P T\n 	foreign_keys\n		f: O -> P\n		g: O -> T\n} \n\nschema S1 = literal : Type {\n	entities \n		Observation Person Gender ObsType\n	foreign_keys \n		f: Observation -> Person\n		h: Person -> Gender\n		g: Observation -> ObsType\n	attributes	\n	     Person_att: Person -> dom\n	     Gender_att: Gender -> dom\n	     ObsType_att: ObsType -> dom\n} \n\nschema S2 = literal : Type {\n	entities \n		Observation Patient Method Type\n	foreign_keys \n		f : Observation -> Patient\n		g1: Observation -> Method\n		g2: Method -> Type\n	attributes\n	     Patient_att: Patient -> dom\n	     Type_att: Type -> dom\n}\n\nmapping F1 = literal : S -> S1 {\n	entities \n		O -> Observation\n		P -> Person\n		T -> ObsType\n	foreign_keys \n		f -> f\n		g -> g\n} \n\nmapping F2 = literal : S -> S2 {\n	entities\n		O -> Observation\n		P -> Patient\n		T -> Type\n	foreign_keys \n		f -> f\n		g -> g1.g2\n} \n\n///////////////////////////////////////////////////////////////////////////\n\n//Pushout schema, written out explicitly here by hand\nschema T = literal : Type {\n	entities \n		O P G T M\n	foreign_keys \n		f : O -> P\n		h : P -> G		\n		g1: O -> M \n		g2: M -> T\n	attributes	\n		G_att : G -> dom\n		T_att1: T -> dom\n		T_att2: T -> dom\n		P_att1: P -> dom\n		P_att2: P -> dom\n} \n\nmapping G1 = literal : S1 -> T {\n	entities \n		Observation -> O\n		Person -> P\n		ObsType -> T\n		Gender -> G\n	foreign_keys \n		f -> f \n		g -> g1.g2\n		h -> h\n	attributes\n		Person_att  -> lambda x. P_att1(x)\n		Gender_att  -> lambda x. G_att(x)\n		ObsType_att -> lambda x. T_att1(x)\n} \n\nmapping G2 = literal : S2 -> T {\n	entities\n		Observation -> O\n		Patient -> P\n		Method -> M\n		Type -> T\n	foreign_keys \n		f  -> f\n		g1 -> g1\n		g2 -> g2\n	attributes\n		Patient_att -> lambda x. P_att2(x)\n		Type_att    -> lambda x. T_att2(x)		\n} \n\n///////////////////////////////////////////////////////////////////////////\n\ninstance I1 = literal : S1 {\n	generators\n		one two three : Observation\n		Peter Paul : Person\n	    	M F :Gender\n	    	BloodPressure BodyWeight HeartRate: ObsType\n	equations\n		Peter.Person_att = xPeter Paul.Person_att = xPaul\n		M.Gender_att = xM F.Gender_att = xF\n		BloodPressure.ObsType_att = xBloodPressure\n		BodyWeight.ObsType_att = xBodyWeight\n		HeartRate.ObsType_att = xHeartRate\n		one.f = Peter two.f = Peter three.f = Paul\n		Peter.h = M Paul.h = M\n		one.g = BloodPressure two.g = BodyWeight three.g = HeartRate\n} \n\ninstance I2 = literal : S2 {\n	generators\n		o1 o2 o3 o4 : Observation\n		Pete Jane : Patient\n		m1 m2 m3 m4 : Method\n		BP Wt : Type\n	equations\n	     Pete.Patient_att = xPete Jane.Patient_att = xJane\n	     BP.Type_att = xBloodPressure Wt.Type_att = xBodyWeight\n	     o1.f = Pete o2.f = Pete o3.f = Jane o4.f = Jane\n	     o1.g1 = m1 o2.g1 = m2 o3.g1 = m3 o4.g1 = m1\n	     m1.g2 = BP m2.g2 = BP m3.g2 = Wt m4.g2 = Wt\n} \n\ninstance I = literal : S {\n	generators \n	  	P : P \n	  	B W : T\n} \n\ntransform a1 = literal : sigma F1 I -> I1 {\n		generators \n			P -> Peter\n			B -> BloodPressure\n			W -> BodyWeight\n} \n\ntransform a2 = literal : sigma F2 I -> I2 {\n		generators\n			P -> Pete\n			B -> BP \n			W-> Wt\n} \n\n///////////////////////////////////////////////////////////////////////////\n\ntransform b1 = sigma G1 a1\ntransform b2 = sigma G2 a2\n\ngraph Span = literal {\n	nodes\n		A B C\n	edges\n		f : A -> B\n		g : A -> C\n}\n\ninstance answer = colimit Span T {\n	nodes\n		A -> src b1\n		B -> dst b1\n		C -> dst b2\n	edges\n		f -> b1\n		g -> b2\n}\n" }

else if (v == "Pullback") { return "typeside Type = literal {\n	java_types	\n		dom = \"java.lang.Object\"\n	java_constants\n		dom = \"return input[0]\"\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nschema CoSpan = literal : Type {\n	entities\n		B C D\n 	foreign_keys\n		f: B -> D\n		g: C -> D\n	attributes\n		B_att : B -> dom\n		C_att : C -> dom	\n} \n\nschema Square = literal : Type {\n	imports\n		CoSpan\n	entities\n		A\n 	foreign_keys\n		f2: A -> B\n		g2: A -> C\n	path_equations\n		f2.f=g2.g\n	attributes\n		A_attB : A -> dom\n		A_attC : A -> dom	\n} \n\nquery pullback = literal : CoSpan -> Square {\n entities\n \n	D -> {from d:D}\n		\n	B -> {from b:B \n		 return B_att -> b.B_att}\n\n	C -> {from c:C \n		 return C_att -> c.C_att}\n\n	A -> {from b0:B c0:C \n		 where b0.f = c0.g \n		 return A_attB -> b0.B_att \n		 	   A_attC -> c0.C_att} \n\nforeign_keys		 	   \n\n	f -> {d -> b.f}\n	g -> {d -> c.g}\n	f2 -> {b -> b0}\n	g2 -> {c -> c0}\n\n}\n\ninstance I = literal : CoSpan {\n	generators\n		b1 b2 : B\n		c1 c2 : C\n		d1 d2 d3 : D\n	equations\n		b1.B_att = \"b1\"@dom\n		b2.B_att = \"b2\"@dom\n		c1.C_att = \"c1\"@dom\n		c2.C_att = \"c2\"@dom\n		b1.f = d1\n		b2.f = d2\n		c1.g = d1\n		c1.g = d3 \n}\n\ninstance J = eval pullback I\n\ntransform t = counit_query pullback I" }

else if (v == "Pushout") { return "typeside Type = literal {\n	java_types	\n		dom = \"java.lang.Object\"\n	java_constants\n		dom = \"return input[0]\"\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nschema Span = literal : Type {\n	entities\n		A B C\n 	foreign_keys\n		f: A -> B\n		g: A -> C\n	attributes\n		C_att : C -> dom\n		B_att : B -> dom	\n} \n\nschema Square = literal : Type {\n	imports\n		Span\n	entities\n		D\n 	foreign_keys\n		f2: B -> D\n		g2: C -> D\n	path_equations\n		f.f2=g.g2\n	attributes\n		D_attB : D -> dom\n		D_attC : D -> dom	\n} \n\nquery pushout = literal : Square -> Span {\n entities\n 		\n	B -> {from b:B \n		 return B_att -> b.f2.D_attB}\n\n	C -> {from c:C \n		 return C_att -> c.g2.D_attC}\n\n	A -> {from a:A} \n\nforeign_keys		 	   \n\n	f -> {b -> a.f}\n	g -> {c -> a.g}\n\n}\n\ninstance J = literal : Span {\n	generators\n		a : A\n		b1 b2 : B\n		c1 c2 : C\n	equations\n		b1.B_att = \"b1\"@dom\n		b2.B_att = \"b2\"@dom\n		c1.C_att = \"c1\"@dom\n		c2.C_att = \"c2\"@dom\n		a.f = b1 \n		a.g = c1\n} \n\ninstance I = coeval pushout J\n\ntransform t = unit_query pushout J" }

else if (v == "Query") { return "typeside Ty = literal { \n	java_types\n		String = \"java.lang.String\"\n		Bool = \"java.lang.Boolean\"\n	java_constants\n		String = \"return input[0]\"\n		Bool = \"return java.lang.Boolean.parseBoolean(input[0])\"\n}\n\n\nschema Source = literal : Ty {\n	entities\n		Man Woman\n	attributes\n		fav_book_m : Man -> String\n		fav_book_w : Woman -> String\n		name_m : Man -> String\n		name_w : Woman -> String\n		paying : Man -> Bool\n} \n\nschema Target = literal : Ty {\n	entities\n		Male GoodMatch PayingGoodMatch\n	foreign_keys\n		is_a : PayingGoodMatch -> GoodMatch\n		for_man : GoodMatch -> Male\n	attributes\n		man_name : Male -> String\n		woman_name : GoodMatch -> String\n} \n\nquery Q = literal : Source -> Target {\n entities\n	GoodMatch -> {\n		from m:Man w:Woman\n		where fav_book_m(m) = fav_book_w(w)\n		return woman_name -> name_w(w)\n	} \n	Male -> {\n		from man:Man\n		return man_name -> name_m(man)\n	} \n	PayingGoodMatch -> {\n		from man:Man woman:Woman\n		where fav_book_m(man) = fav_book_w(woman)\n			 paying(man) = true\n	} \n	\n foreign_keys\n 	is_a -> {m -> man w -> woman}	\n 	for_man -> {man -> m}  \n} \n\ninstance I = literal : Source {\n	generators\n		a d e g : Woman\n		b c f h : Man\n	multi_equations\n		paying -> {b true, c false, f true, h true}\n		name_m -> {b bob, c charlie, f frank, h henry}\n		name_w -> {a alice, d doris, e ellie, g gina}\n		fav_book_m -> {b book1, c book1, f book2, h book3}\n		fav_book_w -> {a book1, d book2, e book2, g book4}		\n} \n\ninstance J = eval Q I\ninstance I0 = literal : Source {\n	generators\n		a0 d0 e0 : Woman\n		b0 c0 f0 : Man\n	multi_equations\n		paying -> {b0 true, c0 false, f0 true}\n		name_m -> {b0 bob, c0 charlie, f0 frank}\n		name_w -> {a0 alice, d0 doris, e0 ellie}\n		fav_book_m -> {b0 book1, c0 book1, f0 book2}\n		fav_book_w -> {a0 book1, d0 book2, e0 book2}		\n} \n\ntransform h = literal : I0 -> I {\n	generators\n		a0 -> a d0 -> d e0 -> e b0 -> b c0 -> c f0 -> f\n} \n\ntransform k = eval Q h\n\ntransform kk = coeval Q k\n" }

else if (v == "Quotient") { return "typeside Ty = empty\n\nschema Likes = literal : Ty {\n	entities\n		Like \n		Person\n	foreign_keys\n		likee : Like -> Person\n		liker : Like -> Person\n}\n\nschema Connections = literal : Ty {\n	entities\n		Connection \n}\n\ninstance SimpsonsLikes = literal : Likes {\n	generators\n		Ned Maud Rodd Todd MrBurns Smithers : Person\n		l1 l2 l3 l4 : Like\n	equations\n		l1.liker = Ned  l1.likee = Maud\n		l2.liker = Maud l2.likee = Rodd\n		l3.liker = Rodd l3.likee =  Todd\n		\n		l4.liker = Smithers l4.likee = MrBurns\n}\n\nmapping FindConnections = literal : Likes -> Connections {\n	entities\n		Person -> Connection\n		Like -> Connection\n	foreign_keys\n		likee -> Connection\n		liker -> Connection	\n}\n\ninstance SimpsonsConnections = sigma FindConnections SimpsonsLikes\n\ntransform whichConnection = unit FindConnections SimpsonsLikes\n" }

else if (v == "Sigma") { return "typeside Type = literal {\n	types \n		String\n	constants\n		gecko frog human cow horse dolphin fish : String\n}\n\nschema C = literal : Type {\n	entities \n		Amphibian\n		LandAnimal\n		WaterAnimal\n	foreign_keys\n		IsAL: Amphibian -> LandAnimal\n		IsAW: Amphibian -> WaterAnimal\n	attributes\n		attA: Amphibian -> String \n		attL: LandAnimal -> String \n		attW: WaterAnimal -> String\n}\n\ninstance I = literal : C {\n	generators \n		a1 a2 : Amphibian\n		l1 l2 l3 l4 l5 : LandAnimal\n		w1 w2 w3 w4 : WaterAnimal\n	equations\n		 attA(a1) = gecko attA(a2) = frog\n		 attL(l1) = gecko attL(l2) = frog \n		 attL(l3) = human attL(l4) = cow \n		 attL(l5) = horse attW(w1) = fish \n		 attW(w2) = gecko attW(w3) = frog \n		 attW(w4) = dolphin IsAL(a1) = l1 \n		 IsAL(a2) = l2 IsAW(a1) = w2 IsAW(a2) = w3\n} \n\nschema D = literal : Type {\n	entities \n		yAmphibian\n		yLandAnimal\n		yWaterAnimal\n		yAnimal\n	foreign_keys\n		yIsAL:yAmphibian->yLandAnimal\n		yIsAW:yAmphibian->yWaterAnimal\n		yIsALL:yLandAnimal->yAnimal\n		yIsAWW:yWaterAnimal->yAnimal\n	path_equations\n		yIsAL.yIsALL = yIsAW.yIsAWW\n	attributes\n		yattA:yAmphibian->String \n		yattL:yLandAnimal->String \n		yattW:yWaterAnimal->String\n} \n\nmapping F = literal : C -> D {\n	entities \n		Amphibian->yAmphibian\n		LandAnimal->yLandAnimal\n		WaterAnimal->yWaterAnimal\n	foreign_keys\n		IsAL -> yIsAL\n		IsAW -> yIsAW\n	attributes\n		attW -> lambda x. yattW(x)\n		attL -> lambda x. yattL(x)\n		attA -> lambda x. yattA(x)\n} \n\ninstance J = sigma F I\n\ninstance I1 = literal : C {\n	generators \n		xa1 : Amphibian\n		xl1 xl2 xl3 xl4 : LandAnimal\n		xw1 xw2 xw3: WaterAnimal\n	equations\n		attL(xl1) = gecko attL(xl2) = frog\n		attL(xl3) = human attL(xl4) = cow\n		attW(xw1) = fish attW(xw2) = gecko\n		attW(xw3) = frog IsAL(xa1) = xl1\n		IsAW(xa1) = xw2 attA(xa1) = gecko\n} \n\ntransform t = literal : I1 -> I {\n	generators \n		xa1 -> a1\n		xl1 -> l1\n		xl2 -> l2\n		xl3 -> l3\n		xl4 -> l4\n		xw1 -> w1\n		xw2 -> w2\n		xw3 -> w3\n} \n\ntransform u = sigma F t\n\ninstance K = delta F J\n\ntransform v = unit F I\n" }

else if (v == "Unit Conv") { return "typeside Ty = literal { \n	java_types\n		in = \"java.lang.Double\"\n		cm = \"java.lang.Double\"		\n	java_constants\n		in = \"return java.lang.Double.parseDouble(input[0])\"\n		cm = \"return java.lang.Double.parseDouble(input[0])\"\n	java_functions\n		inToCm : in -> cm = \"return (2.54 * input[0])\"		\n}\n\nschema AmericanAirplane = literal : Ty {\n	entities \n		Wing\n	attributes\n		wingLength : Wing -> in\n}\n\nschema EuropeanAirplane = literal : Ty {\n	entities \n		Wing\n	attributes\n		wingLength : Wing -> cm\n}\n\nquery AmericanToEuropean = literal : AmericanAirplane -> EuropeanAirplane {\n	entities \n		Wing -> {from w:Wing\n			    return wingLength -> inToCm(w.wingLength)}\n}\n\ninstance Boeing747 = literal : AmericanAirplane {\n	generators\n		left right : Wing\n	equations\n		left.wingLength = right.wingLength\n		left.wingLength = 500	\n}\n\ninstance Boeing747Metric = eval AmericanToEuropean Boeing747\n\n/*\n  Error in query AmericanToEuropean_disastrous_conversion: in attribute wingLength, expected sort of wingLength(w) has sort cm but wingLength(w) actually has sort in\n\nquery AmericanToEuropean_disastrous_conversion = literal : AmericanAirplane -> EuropeanAirplane {\n	entities \n		Wing -> {from w:Wing\n			    return wingLength -> w.wingLength}\n}\n*/\n" }

else return "Unable to find " + v + ".";
};

//}());
  root.AQLEXAMPLES = {
    getExample: getAqlExample
  };
})(this);
