<!doctype html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="author" content="Ken Webb" />
    <meta name="copyright" content="MIT License, Copyright (C) 2019 Ken Webb" />
    
    <script src="xholon/lib/antlr4-require.js"></script>
    
    <!--                                                               -->
    <!-- Consider inlining CSS to reduce the number of requested files -->
    <!--                                                               -->
    <link type="text/css" rel="stylesheet" href="Xholon.css">

    <style>
    pre.antlr {
      border-style: solid;
      border-width: 1px;
      background-color: aliceblue;
    }
    #tree {
        margin-left: 50px;
        float:left;
        clear:right;
    }
    #inputs {
        float:left;
        clear:left;
    }
    .roomElement {
        background: beige;
        /*display: inline-block;*/
        padding: 5px;
        border-radius: 12px;
        border: 1px solid black;
        margin: 10px;
    }
    </style>
    
    <title>Xholon ANTLR - Cypher</title>
    
    <!-- D3 -->
    <script type="text/javascript" language="javascript" src="d3.min.js" charset="utf-8"></script>
    
    <!--                                           -->
    <!-- This script loads your compiled module.   -->
    <!-- If you add any GWT meta tags, they must   -->
    <!-- be added before this line.                -->
    <!--                                           -->
    <script type="text/javascript" language="javascript" src="xholon/xholon.nocache.js"></script>
    
  </head>
  
  <body>
    <!--<h3>Xholon ANTLR - Cypher</h3>-->
    
    <!-- OPTIONAL: include this if you want history support -->
    <!--<iframe src="javascript:''" id="__gwt_historyFrame" tabIndex='-1' style="position:absolute;width:0;height:0;border:0"></iframe>-->
    
    <!-- RECOMMENDED if your web app will not function without JavaScript enabled -->
    <noscript>
      <div style="width: 22em; position: absolute; left: 50%; margin-left: -11em; color: red; background-color: white; border: 1px solid red; padding: 4px; font-family: sans-serif">
        Your web browser must have JavaScript enabled
        in order for this application to display correctly.
      </div>
    </noscript>

    <!-- Each of the following can have sub-div elements. -->
    <div id="xhtop">
      <h3 id="xholontitle" style="display: inline;">Xholon</h3>
      <span id="timestep" style="padding-left: 20px; font-size: 13px;">0</span>:<span id="maxprocessloops" style="font-size: 13px;">&infin;</span>
    </div>
    
    <!-- default GWT-based GUI -->
    <div id="xhgui"></div>
    
    <!-- reserved for app-specific use -->
    <div id="xhappspecific"></div>
    
    <div id="xhconsole">
      <!--<div id="xhout"></div> will be added as a tab in a TabLayoutPanel -->
      <!--<div id="xhclipboard"></div>  will be added as a tab in a TabLayoutPanel -->
      <!-- instances of node-specific XholonConsole -->
    </div>
    
    <!-- text: much of which could use CodeMirror/Ace -->
    <div id="xhtabs"></div>
    
    <!-- data: line chart, pie chart, other Google charts, etc. -->
    <div id="xhchart"></div>
    
    <!-- HTML5 canvas -->
    <div id="xhcanvas"></div>
    
    <!-- structure: network, tree, Google/D3 Treemap, D3 charts/graphs, etc. -->
    <div id="xhgraph">
      <div id="networkview"></div>
      <div id="treeview"></div>
      <div id="xhtreemap"></div>
    </div>
    
    <!-- SVG and other animations, such as those with Animate.java
         Each separate animation should have its own child div -->
    <div id="xhanim"></div>
    
    <!-- static SVG images -->
    <div id="xhsvg"></div>
    
    <!-- PNG, etc. -->
    <div id="xhimg"></div>
    
    <!-- Include Zepto with a script tag near the end of your page. -->
    <!--<script src="zepto.min.js"></script>-->
    
    <!-- QUnit unit testing -->
    <div id="xhunittest">
      <!-- these are required by QUnit -->
      <div id="qunit"></div>
      <div id="qunit-fixture"></div>
    </div>

    <!-- http://127.0.0.1:8888/XholonAntlr_Cypher.html?app=HelloWorld&gui=clsc -->
    <!--<p>This is an <a href="">Cypher</a> model.</p>-->
    <!--<pre class="antlr">
Cypher grammar
    </pre>-->
    
    <div id="inputs">
      <!--
// example from: https://neo4j.com/developer/cypher-basics-i/
//data stored with this direction
CREATE (p:Person)-[:LIKES]->(t:Technology)

//query relationship backwards will not return results
MATCH (p:Person)<-[:LIKES]-(t:Technology)

//better to query with undirected relationship unless sure of direction
MATCH (p:Person)-[:LIKES]-(t:Technology)    
      -->
      <textarea style = "display: none;" id="xhcypher">
CREATE (abc)
CREATE (def)
CREATE (ghi)
</textarea>
      <br/>
      <button id="parse">Parse</button>
    </div>
    
    <script type="text/javascript">
var updateTree = function(tree) { //, literalNames, ruleNames, symbolicNames) {
  console.log(ruleNames);
  var nodeTypeT = ruleNames[tree.ruleIndex];
  console.log(nodeTypeT);
  switch (nodeTypeT) {
  case "oC_Cypher":
    xmlStrCSH += "<XholonNull>\n";
    break;
  default:
    break;
  }
  for (var i = 0; i < tree.children.length; i++) {
    var child = tree.children[i];
    console.log(child);
    var nodeType = ruleNames[child.ruleIndex];
    if (nodeType) {
      console.log(nodeType);
    }
    else {
      if (child.symbol) {
        nodeType = symbolicNames[child.symbol.type];
        console.log(nodeType);
      }
      else {
        console.log(child.getText());
      }
    }
    // Cypher = [SP], Statement, [[SP], ';'], [SP], EOI ;
    switch (nodeType) {
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case "oC_Statement":
      console.log("an oC_Statement");
      statement(child);
      break;
    case null:
    case undefined:
      break;
    default:
      console.log(nodeType);
      break;
    }
  }
  switch (nodeTypeT) {
  case "oC_Cypher":
    xmlStrCSH += "</XholonNull>";
    break;
  default:
    break;
  }
};

// @deprecated ???
var recurseChild = function(child, ruleNames) {
  if (!child) {return;}
  var nodeType = ruleNames[child.ruleIndex];
  console.log(nodeType);
  switch (nodeType) {
  case "aaa":
    //aaa(child, ruleNames);
    break;
  case "bbb":
    //bbb(child, ruleNames);
    return;
  case "ccc":
    //ccc(child, ruleNames);
    return;
  case "ddd":
    //ddd(child, ruleNames);
    return;
  case "eee":
    //eee(child, ruleNames);
    return;
  default:
    break;
  }
  if (child.children) {
    for (var j = 0; j < child.children.length; j++) {
      console.log("" + j + " " + child.children[j].getText());
      recurseChild(child.children[j], ruleNames);
    }
  }
}

// TODO use a single recurse() function to drill down to something concrete ???

// Statement = Query ;
var statement = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_Query":
      console.log("an oC_Query");
      query(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Query = RegularQuery | StandaloneCall ;
var query = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_RegularQuery":
      console.log("an oC_RegularQuery");
      regularQuery(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// RegularQuery = SingleQuery, { [SP], Union } ;
var regularQuery = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_SingleQuery":
      console.log("an oC_SingleQuery");
      singleQuery(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// SingleQuery = SinglePartQuery | MultiPartQuery ;
var singleQuery = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_SinglePartQuery":
      console.log("an oC_SinglePartQuery");
      singlePartQuery(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// SinglePartQuery = ({ ReadingClause, [SP] }, Return) | ({ ReadingClause, [SP] }, UpdatingClause, { [SP], UpdatingClause }, [[SP], Return]) ;
var singlePartQuery = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_UpdatingClause":
      console.log("an oC_UpdatingClause");
      updatingClause(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// UpdatingClause = Create | Merge | Delete | Set | Remove ;
var updatingClause = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_Create":
      console.log("an oC_Create");
      create(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Create = (C,R,E,A,T,E), [SP], Pattern ;
var create = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "CREATE":
      console.log("a CREATE");
      // TODO ???
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case "oC_Pattern":
      console.log("an oC_Pattern");
      pattern(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Pattern = PatternPart, { [SP], ',', [SP], PatternPart } ;
var pattern = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_PatternPart":
      console.log("an oC_PatternPart");
      patternPart(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// PatternPart = (Variable, [SP], '=', [SP], AnonymousPatternPart) | AnonymousPatternPart ;
var patternPart = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_Variable":
      console.log("an oC_Variable");
      //variable(child);
      break;
    case "oC_AnonymousPatternPart":
      console.log("an oC_AnonymousPatternPart");
      anonymousPatternPart(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Variable = SymbolicName ;
var variable = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_SymbolicName":
      console.log("an oC_SymbolicName");
      symbolicName(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}


// AnonymousPatternPart = PatternElement ;
var anonymousPatternPart = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_PatternElement":
      console.log("an oC_PatternElement");
      patternElement(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// PatternElement = (NodePattern, { [SP], PatternElementChain }) | ('(', PatternElement, ')') ;
var patternElement = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_PatternElementChain":
      console.log("an oC_PatternElementChain");
      patternElementChain(child);
      break;
    case "oC_PatternElement":
      console.log("an oC_PatternElement");
      patternElement(child);
      break;
    case "oC_NodePattern":
      console.log("an oC_NodePattern");
      nodePattern(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// PatternElementChain = RelationshipPattern, [SP], NodePattern ;
var patternElementChain = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_RelationshipPattern":
      console.log("an oC_RelationshipPattern");
      //relationshipPattern(child);
      break;
    case "oC_NodePattern":
      console.log("an oC_NodePattern");
      nodePattern(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// NodePattern = '(', [SP], [Variable, [SP]], [NodeLabels, [SP]], [Properties, [SP]], ')' ;
var nodePattern = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_Variable":
      console.log("an oC_Variable");
      variable(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

/*
SymbolicName = UnescapedSymbolicName
             | EscapedSymbolicName
             | HexLetter
             | (C,O,U,N,T)
             | (F,I,L,T,E,R)
             | (E,X,T,R,A,C,T)
             | (A,N,Y)
             | (N,O,N,E)
             | (S,I,N,G,L,E)
             ;
*/
var symbolicName = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "UnescapedSymbolicName": // a symbol
      console.log("an UnescapedSymbolicName");
      unescapedSymbolicName(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// UnescapedSymbolicName = IdentifierStart, { IdentifierPart } ;
var unescapedSymbolicName = function(node) {
  // this type of node does not have children
  console.log(node.getText());
  xmlStrCSH += '<Hello roleName="' + node.getText() + '"/>\n';
  /*
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "IdentifierStart": // a symbol
      console.log("an IdentifierStart");
      identifierStart(child);
      break;
    case "IdentifierPart": // a symbol
      console.log("an IdentifierPart");
      identifierPart(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }*/
}

// IdentifierStart = ID_Start | Pc ;
var identifierStart = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_ID_Start":
      console.log("an oC_ID_Start");
      // any of 125,884 unicode code points
      //id_Start(child);
      console.log(child.children);
      break;
    case "ID_Start": // not sure if this is a rule or a symbol
      console.log("an ID_Start");
      // any of 125,884 unicode code points
      //id_Start(child);
      console.log(child.children);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// IdentifierPart = ID_Continue | Sc ;
var identifierPart = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_ID_Continue": // not sure if this is a rule or a symbol
      console.log("an oC_ID_Continue");
      // any of 128,789 unicode Code Points
      //id_Continue(child);
      console.log(child.children);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// 

// 

var getNodeType = function(node) {
  console.log(node);
  //if (node.getPayload) {console.log(node.getPayload())};
  //if (node.getSymbol) {console.log(node.getSymbol())};
  //if (node.getText) {console.log(node.getText())};
  //console.log(node.toString());
  var nodeType = ruleNames[node.ruleIndex];
  if (nodeType) {
    console.log("RULE " + nodeType);
  }
  else {
    if (node.symbol) {
      nodeType = symbolicNames[node.symbol.type];
      console.log("SYMBOL " + nodeType);
    }
    else {
      console.log("NOT RULE|SYMBOL " + node.getText());
    }
  }
  if (!nodeType) {
    nodeType = null;
  }
  return nodeType;
}

// main
var antlr4 = require('xholon/lib/antlr4/index');
var CypherLexer = require('xholon/lib/antlr4g/CypherLexer');
var CypherParser = require('xholon/lib/antlr4g/CypherParser');
var CypherListener = require('xholon/lib/antlr4g/CypherListener');

var xmlStrIH = "<_-.XholonClass>\n  <TheSystem/>\n";
var xmlStrCD = "<xholonClassDetails>\n";
var xmlStrCSH = "<TheSystem>";

var nextActivityId = 1;
var actorClassContextName = null;
var transArr = null;
var seekingTopActor = false;

// behavior for one specific StateMachine, for an ActorClass with a Behavior
var beh = null;
//var bindings = {}; //[]; // cache all Binding(s) here
var actorRefObj = null;

var literalNames, ruleNames, symbolicNames;

document.getElementById("parse").addEventListener("click", function(){
  var input = document.getElementById("xhcypher").value;
  console.log(input);
  var chars = new antlr4.InputStream(input);
  var lexer = new CypherLexer.CypherLexer(chars);
  var tokens  = new antlr4.CommonTokenStream(lexer);
  var parser = new CypherParser.CypherParser(tokens);
  parser.buildParseTrees = true;
  console.log(parser);
  var tree = parser.oC_Cypher();
  console.log("Parsed: "+ tree);
  literalNames = parser.literalNames;
  ruleNames = parser.ruleNames;
  symbolicNames = parser.symbolicNames;
  updateTree(tree); //, parser.literalNames, parser.ruleNames, parser.symbolicNames);
  //
  xmlStrIH += "</_-.XholonClass>\n";
  xmlStrCD += '\n'
    + '  <XholonClass xhType="XhtypePureContainer"/>\n'
    ;
  xmlStrCD += "</xholonClassDetails>\n";
  xmlStrCSH += "</TheSystem>\n";
  console.log(xmlStrIH);
  console.log(xmlStrCD);
  console.log(xmlStrCSH);
  //console.log(bindings);
  if (xh) {
    var rootIH = xh.app().first().next().next().first().next().first();
    console.log(rootIH);
    rootIH.append(xmlStrIH);
    rootIH.append(xmlStrCD);
    var rootCSH = xh.root();
    console.log(rootCSH);
    rootCSH.println(xmlStrCSH);
    rootCSH.append(xmlStrCSH);
  }
  if (beh) {
    // write out the last behavior
    console.log(beh);
  }
});

    </script>
    
    <!--<div id="tree"></div>-->
    
    <div id="xhfooter">
    <hr/>
    <div class="license"  style="font-size: 9px;"><p>Xholon GWT is a <a href="index.html">Xholon</a> project. Copyright (C) 2017 Ken Webb</p></div>
    <div class="aatt" style="font-size: 9px;"><pre style="font-size: 9px;">
  @QWERTYUIk
  OPASmDFGHe
  primordion
  JKLZcXCVB.
    </pre></div>

  </body>
  
</html>
