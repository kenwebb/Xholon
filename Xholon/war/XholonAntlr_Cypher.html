<!doctype html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="author" content="Ken Webb" />
    <meta name="copyright" content="MIT License, Copyright (C) 2019 Ken Webb" />
    
    <script src="xholon/lib/antlr4-require.js"></script>
    
    <!--                                                               -->
    <!-- Consider inlining CSS to reduce the number of requested files -->
    <!--                                                               -->
    <link type="text/css" rel="stylesheet" href="Xholon.css">

    <style>
    pre.antlr {
      border-style: solid;
      border-width: 1px;
      background-color: aliceblue;
    }
    #tree {
        margin-left: 50px;
        float:left;
        clear:right;
    }
    #inputs {
        float:left;
        clear:left;
    }
    .roomElement {
        background: beige;
        /*display: inline-block;*/
        padding: 5px;
        border-radius: 12px;
        border: 1px solid black;
        margin: 10px;
    }
    </style>
    
    <title>Xholon ANTLR - Cypher</title>
    
    <!-- D3 -->
    <script type="text/javascript" language="javascript" src="d3.min.js" charset="utf-8"></script>
    
    <!--                                           -->
    <!-- This script loads your compiled module.   -->
    <!-- If you add any GWT meta tags, they must   -->
    <!-- be added before this line.                -->
    <!--                                           -->
    <script type="text/javascript" language="javascript" src="xholon/xholon.nocache.js"></script>
    
  </head>
  
  <body>
    <!--<h3>Xholon ANTLR - Cypher</h3>-->
    
    <!-- OPTIONAL: include this if you want history support -->
    <!--<iframe src="javascript:''" id="__gwt_historyFrame" tabIndex='-1' style="position:absolute;width:0;height:0;border:0"></iframe>-->
    
    <!-- RECOMMENDED if your web app will not function without JavaScript enabled -->
    <noscript>
      <div style="width: 22em; position: absolute; left: 50%; margin-left: -11em; color: red; background-color: white; border: 1px solid red; padding: 4px; font-family: sans-serif">
        Your web browser must have JavaScript enabled
        in order for this application to display correctly.
      </div>
    </noscript>

    <!-- Each of the following can have sub-div elements. -->
    <div id="xhtop">
      <h3 id="xholontitle" style="display: inline;">Xholon</h3>
      <span id="timestep" style="padding-left: 20px; font-size: 13px;">0</span>:<span id="maxprocessloops" style="font-size: 13px;">&infin;</span>
    </div>
    
    <!-- default GWT-based GUI -->
    <div id="xhgui"></div>
    
    <!-- reserved for app-specific use -->
    <div id="xhappspecific"></div>
    
    <div id="xhconsole">
      <!--<div id="xhout"></div> will be added as a tab in a TabLayoutPanel -->
      <!--<div id="xhclipboard"></div>  will be added as a tab in a TabLayoutPanel -->
      <!-- instances of node-specific XholonConsole -->
    </div>
    
    <!-- text: much of which could use CodeMirror/Ace -->
    <div id="xhtabs"></div>
    
    <!-- data: line chart, pie chart, other Google charts, etc. -->
    <div id="xhchart"></div>
    
    <!-- HTML5 canvas -->
    <div id="xhcanvas"></div>
    
    <!-- structure: network, tree, Google/D3 Treemap, D3 charts/graphs, etc. -->
    <div id="xhgraph">
      <div id="networkview"></div>
      <div id="treeview"></div>
      <div id="xhtreemap"></div>
    </div>
    
    <!-- SVG and other animations, such as those with Animate.java
         Each separate animation should have its own child div -->
    <div id="xhanim"></div>
    
    <!-- static SVG images -->
    <div id="xhsvg"></div>
    
    <!-- PNG, etc. -->
    <div id="xhimg"></div>
    
    <!-- Include Zepto with a script tag near the end of your page. -->
    <!--<script src="zepto.min.js"></script>-->
    
    <!-- QUnit unit testing -->
    <div id="xhunittest">
      <!-- these are required by QUnit -->
      <div id="qunit"></div>
      <div id="qunit-fixture"></div>
    </div>

    <!-- http://127.0.0.1:8888/XholonAntlr_Cypher.html?app=HelloWorld&gui=clsc -->
    <!--<p>This is an <a href="">Cypher</a> model.</p>-->
    <!--<pre class="antlr">
Cypher grammar
    </pre>-->
    
    <!--
The steps in my process:
() Download and install antlr
() Download the Cypher grammar Cypher.g4
 - install in ~/JavaThirdParty/antlr4
() Compile
 cd ~/JavaThirdParty/antlr4
 java -jar antlr-4.7-complete.jar -Dlanguage=JavaScript Cypher.g4
() this generates the following files in the same directory:
 CypherLexer.js
 CypherLexer.tokens
 CypherListener.js
 CypherParser.js
 Cypher.tokens
() Manually copy all six files, including Cypher.g4, to the Xholon source directory ~/gwtspace/Xholon/Xholon/src/org/public/lib/antlr4g
() Edit 3 of the .js files to convert  'antlr4/index' to 'xholon/lib/antlr4/index'
() Copy all six files from the source to the Xholon runtime directory ~/gwtspace/Xholon/Xholon/war/xholon/lib/antlr4g
 cd ~/gwtspace/Xholon/Xholon
 ant -Dgwt.args="-strict" gwtc
() Load this .html file (XholonAntlr_Cypher.html) along with any Xholon app
 http://127.0.0.1:8888/XholonAntlr_Cypher.html?app=023f0fc135244e988a831dd8f8364679&src=gist&gui=clsc
() Click the "Parse" button.
() Observe the output in the "out" tab and in the browser Dev Tools console.
    -->
    
    <div id="inputs">
      <!--
// example from: https://neo4j.com/developer/cypher-basics-i/
//data stored with this direction
CREATE (p:Person)-[:LIKES]->(t:Technology)

//query relationship backwards will not return results
MATCH (p:Person)<-[:LIKES]-(t:Technology)

//better to query with undirected relationship unless sure of direction
MATCH (p:Person)-[:LIKES]-(t:Technology)

CREATE (adam:User {name: 'Adam'}), (pernilla:User {name: 'Pernilla'}), (david:User {name: 'David'}), (adam)-[:FRIEND]->(pernilla), (pernilla)-[:FRIEND]->(david)
CREATE
(helloWorldSystem_0 {state: 0}),
(hello_2 {state: 0}),
(world_3 {state: 1}),
(xholonInternalServices_0),
(serviceLocatorService_1),
(xPathService_2),
(xPath_4),
(xholonDirectoryService_3),
(aboutService_4),
(chartViewerService_5),
(xholonMap_6),
(attribute_String_5 {roleName: "ChartViewerService-JFreeChart"})
CREATE (bcd {cde: 'this is the x2 property'})
CREATE (fgh {ijk: This is some text.})
CREATE (fgh {ijk: "This is some text."})
      -->
      <textarea style = "display: none;" id="xhcypher">
   
CREATE (abc)
CREATE (def)
CREATE (ghi)
CREATE (jkl),(mno)
CREATE (p:Person)-[:LIKES]->(t:Technology)
CREATE
(helloWorldSystem_0 {state: 0}),
(hello_2 {state: 0}),
(world_3 {state: 1}),
(xholonInternalServices_0),
(serviceLocatorService_1),
(xPathService_2),
(xPath_4),
(xholonDirectoryService_3),
(aboutService_4),
(chartViewerService_5),
(xholonMap_6)
CREATE (bcd {cde: 12345.67})
</textarea>
      <br/>
      <button id="parse">Parse</button>
    </div>
    
    <script type="text/javascript">
var updateTree = function(tree) { //, literalNames, ruleNames, symbolicNames) {
  console.log(ruleNames);
  var nodeTypeT = ruleNames[tree.ruleIndex];
  console.log(nodeTypeT);
  switch (nodeTypeT) {
  case "oC_Cypher":
    xmlStrCSH += "<XholonNull>\n";
    break;
  default:
    break;
  }
  for (var i = 0; i < tree.children.length; i++) {
    var child = tree.children[i];
    console.log(child);
    var nodeType = ruleNames[child.ruleIndex];
    if (nodeType) {
      console.log(nodeType);
    }
    else {
      if (child.symbol) {
        nodeType = symbolicNames[child.symbol.type];
        console.log(nodeType);
      }
      else {
        console.log(child.getText());
      }
    }
    // Cypher = [SP], Statement, [[SP], ';'], [SP], EOI ;
    switch (nodeType) {
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case "oC_Statement":
      console.log("an oC_Statement");
      statement(child);
      break;
    case "EOI":
      console.log("a symbolicName EOI");
      // ignore the EOI
      break;
    case null:
    case undefined:
      break;
    default:
      console.log(nodeType);
      break;
    }
  }
  switch (nodeTypeT) {
  case "oC_Cypher":
    xmlStrCSH += "</XholonNull>";
    break;
  default:
    break;
  }
};

// @deprecated ???
var recurseChild = function(child, ruleNames) {
  if (!child) {return;}
  var nodeType = ruleNames[child.ruleIndex];
  console.log(nodeType);
  switch (nodeType) {
  case "aaa":
    //aaa(child, ruleNames);
    break;
  case "bbb":
    //bbb(child, ruleNames);
    return;
  case "ccc":
    //ccc(child, ruleNames);
    return;
  case "ddd":
    //ddd(child, ruleNames);
    return;
  case "eee":
    //eee(child, ruleNames);
    return;
  default:
    break;
  }
  if (child.children) {
    for (var j = 0; j < child.children.length; j++) {
      console.log("" + j + " " + child.children[j].getText());
      recurseChild(child.children[j], ruleNames);
    }
  }
}

// TODO use a single recurse() function to drill down to something concrete ???

// Statement = Query ;
var statement = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_Query":
      console.log("an oC_Query");
      query(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Query = RegularQuery | StandaloneCall ;
var query = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_RegularQuery":
      console.log("an oC_RegularQuery");
      regularQuery(child);
      break;
    case "oC_StandaloneCall":
      console.log("an oC_StandaloneCall");
      //standaloneCall(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// RegularQuery = SingleQuery, { [SP], Union } ;
var regularQuery = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_SingleQuery":
      console.log("an oC_SingleQuery");
      singleQuery(child);
      break;
    case "oC_Union":
      console.log("an oC_Union");
      //union(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// SingleQuery = SinglePartQuery | MultiPartQuery ;
var singleQuery = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_SinglePartQuery":
      console.log("an oC_SinglePartQuery");
      singlePartQuery(child);
      break;
    case "oC_MultiPartQuery":
      console.log("an oC_MultiPartQuery");
      //multiPartQuery(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// SinglePartQuery = ({ ReadingClause, [SP] }, Return) | ({ ReadingClause, [SP] }, UpdatingClause, { [SP], UpdatingClause }, [[SP], Return]) ;
var singlePartQuery = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_UpdatingClause":
      console.log("an oC_UpdatingClause");
      updatingClause(child);
      break;
    case "oC_ReadingClause":
      console.log("an oC_ReadingClause");
      readingClause(child);
      break;
    case "oC_Return":
      console.log("an oC_Return");
      rreturn(child); // note the double r, so it doesn't conflict with JS "return"
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// ReadingClause = Match | Unwind | InQueryCall ;
var readingClause = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_Match":
      console.log("an oC_Match");
      //match(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// UpdatingClause = Create | Merge | Delete | Set | Remove ;
var updatingClause = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_Create":
      console.log("an oC_Create");
      create(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Return = (R,E,T,U,R,N), [[SP], (D,I,S,T,I,N,C,T)], SP, ReturnBody ;
// note the double r, so it doesn't conflict with JS "return"
var rreturn = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_ReturnBody":
      console.log("an oC_ReturnBody");
      //returnBody(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Create = (C,R,E,A,T,E), [SP], Pattern ;
var create = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "CREATE":
      console.log("a CREATE");
      // TODO ???
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case "oC_Pattern":
      console.log("an oC_Pattern");
      pattern(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Pattern = PatternPart, { [SP], ',', [SP], PatternPart } ;
var pattern = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_PatternPart":
      console.log("an oC_PatternPart");
      patternPart(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// PatternPart = (Variable, [SP], '=', [SP], AnonymousPatternPart) | AnonymousPatternPart ;
var patternPart = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_Variable":
      console.log("an oC_Variable");
      variable(child);
      break;
    case "oC_AnonymousPatternPart":
      console.log("an oC_AnonymousPatternPart");
      anonymousPatternPart(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Variable = SymbolicName ;
var variable = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_SymbolicName":
      console.log("an oC_SymbolicName");
      symbolicName(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}


// AnonymousPatternPart = PatternElement ;
var anonymousPatternPart = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_PatternElement":
      console.log("an oC_PatternElement");
      patternElement(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// PatternElement = (NodePattern, { [SP], PatternElementChain }) | ('(', PatternElement, ')') ;
var patternElement = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_PatternElementChain":
      console.log("an oC_PatternElementChain");
      patternElementChain(child);
      break;
    case "oC_PatternElement":
      console.log("an oC_PatternElement");
      patternElement(child);
      break;
    case "oC_NodePattern":
      console.log("an oC_NodePattern");
      nodePattern(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// PatternElementChain = RelationshipPattern, [SP], NodePattern ;
var patternElementChain = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_RelationshipPattern":
      console.log("an oC_RelationshipPattern");
      relationshipPattern(child);
      break;
    case "oC_NodePattern":
      console.log("an oC_NodePattern");
      nodePattern(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

/*
RelationshipPattern = (LeftArrowHead, [SP], Dash, [SP], [RelationshipDetail], [SP], Dash, [SP], RightArrowHead)
                    | (LeftArrowHead, [SP], Dash, [SP], [RelationshipDetail], [SP], Dash)
                    | (Dash, [SP], [RelationshipDetail], [SP], Dash, [SP], RightArrowHead)
                    | (Dash, [SP], [RelationshipDetail], [SP], Dash)
                    ;
*/
var relationshipPattern = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_RelationshipDetail":
      console.log("an oC_RelationshipDetail");
      //relationshipDetail(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// NodePattern = '(', [SP], [Variable, [SP]], [NodeLabels, [SP]], [Properties, [SP]], ')' ;
var nodePattern = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_Variable":
      console.log("an oC_Variable");
      variable(child);
      break;
    case "oC_NodeLabels":
      console.log("an oC_NodeLabels");
      nodeLabels(child);
      break;
    case "oC_Properties":
      console.log("an oC_Variable");
      properties(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// NodeLabels = NodeLabel, { [SP], NodeLabel } ;
var nodeLabels = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_NodeLabel":
      console.log("an oC_NodeLabel");
      nodeLabel(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// NodeLabel = ':', [SP], LabelName ;
var nodeLabel = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_LabelName":
      console.log("an oC_LabelName");
      labelName(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// LabelName = SchemaName ;
var labelName = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_SchemaName":
      console.log("an oC_SchemaName");
      schemaName(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// SchemaName = SymbolicName | ReservedWord ;
var schemaName = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_SymbolicName":
      console.log("an oC_SymbolicName");
      symbolicName(child);
      break;
    case "oC_ReservedWord":
      console.log("an oC_ReservedWord");
      //reservedWord(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Properties = MapLiteral | Parameter ;
var properties = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_MapLiteral":
      console.log("an oC_MapLiteral");
      mapLiteral(child);
      break;
    case "oC_Parameter":
      console.log("an oC_Parameter");
      parameter(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// MapLiteral = '{', [SP], [PropertyKeyName, [SP], ':', [SP], Expression, [SP], { ',', [SP], PropertyKeyName, [SP], ':', [SP], Expression, [SP] }], '}' ;
var mapLiteral = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_PropertyKeyName":
      console.log("an oC_PropertyKeyName");
      propertyKeyName(child);
      break;
    case "oC_Expression":
      console.log("an oC_Expression");
      expression(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// PropertyKeyName = SchemaName ;
var propertyKeyName = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_SchemaName":
      console.log("an oC_SchemaName");
      schemaName(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Expression = OrExpression ;
var expression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_OrExpression":
      console.log("an oC_OrExpression");
      orExpression(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// OrExpression = XorExpression, { SP, (O,R), SP, XorExpression } ;
var orExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_XorExpression":
      console.log("an oC_XorExpression");
      xorExpression(child);
      break;
    case "OR":
      console.log("a symbolicName OR");
      // ignore the OR
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// XorExpression = AndExpression, { SP, (X,O,R), SP, AndExpression } ;
var xorExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_AndExpression":
      console.log("an oC_AndExpression");
      andExpression(child);
      break;
    case "XOR":
      console.log("a symbolicName XOR");
      // ignore the XOR
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// AndExpression = NotExpression, { SP, (A,N,D), SP, NotExpression } ;
var andExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_NotExpression":
      console.log("an oC_NotExpression");
      notExpression(child);
      break;
    case "AND":
      console.log("a symbolicName AND");
      // ignore the AND
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// NotExpression = { (N,O,T), [SP] }, ComparisonExpression ;
var notExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_ComparisonExpression":
      console.log("an oC_ComparisonExpression");
      comparisonExpression(child);
      break;
    case "NOT":
      console.log("a symbolicName NOT");
      // ignore the NOT
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// ComparisonExpression = AddOrSubtractExpression, { [SP], PartialComparisonExpression } ;
var comparisonExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_AddOrSubtractExpression":
      console.log("an oC_AddOrSubtractExpression");
      addOrSubtractExpression(child);
      break;
    case "oC_PartialComparisonExpression":
      console.log("an oC_PartialComparisonExpression");
      //partialComparisonExpression(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// AddOrSubtractExpression = MultiplyDivideModuloExpression, { ([SP], '+', [SP], MultiplyDivideModuloExpression) | ([SP], '-', [SP], MultiplyDivideModuloExpression) } ;
var addOrSubtractExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_MultiplyDivideModuloExpression":
      console.log("an oC_MultiplyDivideModuloExpression");
      multiplyDivideModuloExpression(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// MultiplyDivideModuloExpression = PowerOfExpression, { ([SP], '*', [SP], PowerOfExpression) | ([SP], '/', [SP], PowerOfExpression) | ([SP], '%', [SP], PowerOfExpression) } ;
var multiplyDivideModuloExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_PowerOfExpression":
      console.log("an oC_PowerOfExpression");
      powerOfExpression(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// PowerOfExpression = UnaryAddOrSubtractExpression, { [SP], '^', [SP], UnaryAddOrSubtractExpression } ;
var powerOfExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_UnaryAddOrSubtractExpression":
      console.log("an oC_UnaryAddOrSubtractExpression");
      unaryAddOrSubtractExpression(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// UnaryAddOrSubtractExpression = { ('+' | '-'), [SP] }, StringListNullOperatorExpression ;
var unaryAddOrSubtractExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_StringListNullOperatorExpression":
      console.log("an oC_StringListNullOperatorExpression");
      stringListNullOperatorExpression(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// StringListNullOperatorExpression = PropertyOrLabelsExpression, { StringOperatorExpression | ListOperatorExpression | NullOperatorExpression } ;
var stringListNullOperatorExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_PropertyOrLabelsExpression":
      console.log("an oC_PropertyOrLabelsExpression");
      propertyOrLabelsExpression(child);
      break;
    case "oC_StringOperatorExpression":
      console.log("an oC_StringOperatorExpression");
      stringOperatorExpression(child);
      break;
    case "oC_ListOperatorExpression":
      console.log("an oC_ListOperatorExpression");
      listOperatorExpression(child);
      break;
    case "oC_NullOperatorExpression":
      console.log("an oC_NullOperatorExpression");
      nullOperatorExpression(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// ListOperatorExpression = (SP, (I,N), [SP], PropertyOrLabelsExpression) | ([SP], '[', Expression, ']') | ([SP], '[', [Expression], '..', [Expression], ']') ;
var listOperatorExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_PropertyOrLabelsExpression":
      console.log("an oC_PropertyOrLabelsExpression");
      propertyOrLabelsExpression(child);
      break;
    case "oC_Expression":
      console.log("an oC_Expression");
      expression(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// StringOperatorExpression = ((SP, (S,T,A,R,T,S), SP, (W,I,T,H)) | (SP, (E,N,D,S), SP, (W,I,T,H)) | (SP, (C,O,N,T,A,I,N,S))), [SP], PropertyOrLabelsExpression ;
var stringOperatorExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_PropertyOrLabelsExpression":
      console.log("an oC_PropertyOrLabelsExpression");
      propertyOrLabelsExpression(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// NullOperatorExpression = (SP, (I,S), SP, (N,U,L,L)) | (SP, (I,S), SP, (N,O,T), SP, (N,U,L,L)) ;
var nullOperatorExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// PropertyOrLabelsExpression = Atom, { [SP], PropertyLookup }, [[SP], NodeLabels] ;
var propertyOrLabelsExpression = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_Atom":
      console.log("an oC_Atom");
      atom(child);
      break;
    case "oC_PropertyLookup":
      console.log("an oC_PropertyLookup");
      propertyLookup(child);
      break;
    case "oC_NodeLabels":
      console.log("an oC_NodeLabels");
      nodeLabels(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

/*
Atom = Literal
     | Parameter
     | CaseExpression
     | ((C,O,U,N,T), [SP], '(', [SP], '*', [SP], ')')
     | ListComprehension
     | PatternComprehension
     | ((A,L,L), [SP], '(', [SP], FilterExpression, [SP], ')')
     | ((A,N,Y), [SP], '(', [SP], FilterExpression, [SP], ')')
     | ((N,O,N,E), [SP], '(', [SP], FilterExpression, [SP], ')')
     | ((S,I,N,G,L,E), [SP], '(', [SP], FilterExpression, [SP], ')')
     | RelationshipsPattern
     | ParenthesizedExpression
     | FunctionInvocation
     | Variable
     ;
*/
var atom = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_Literal":
      console.log("an oC_Literal");
      literal(child);
      break;
    case "oC_Variable":
      console.log("an oC_Variable");
      variable(child);
      break;
    case "SP":
      console.log("a symbolicName SP");
      // ignore the SP
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

/*
Literal = NumberLiteral
        | StringLiteral
        | BooleanLiteral
        | (N,U,L,L)
        | MapLiteral
        | ListLiteral
        ;
*/
var literal = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_NumberLiteral":
      console.log("an oC_NumberLiteral");
      numberLiteral(child);
      break;
    case "StringLiteral": // there is no "oC_StringLiteral", only "StringLiteral"
      console.log("a StringLiteral " + child.getText());
      stringLiteral(child);
      break;
    case "oC_BooleanLiteral":
      console.log("an oC_BooleanLiteral");
      //booleanLiteral(child);
      break;
    case "NULL":
      console.log("a NULL");
      // 
      break;
    case "oC_MapLiteral":
      console.log("an oC_MapLiteral");
      mapLiteral(child);
      break;
    case "oC_ListLiteral":
      console.log("an oC_ListLiteral");
      //listLiteral(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// NumberLiteral = DoubleLiteral | IntegerLiteral ;
var numberLiteral = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_DoubleLiteral":
      console.log("an oC_DoubleLiteral");
      doubleLiteral(child);
      break;
    case "oC_IntegerLiteral":
      console.log("an oC_IntegerLiteral");
      integerLiteral(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// DoubleLiteral = ExponentDecimalReal | RegularDecimalReal ;
var doubleLiteral = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "ExponentDecimalReal":
      console.log("an ExponentDecimalReal " + child.getText());
      break;
    case "RegularDecimalReal":
      console.log("a RegularDecimalReal " + child.getText());
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// RegularDecimalReal = { Digit }, '.', { Digit }- ;
/*var regularDecimalReal = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "Digit":
      console.log("an Digit");
      //digit(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}*/

// IntegerLiteral = HexInteger | OctalInteger | DecimalInteger ;
var integerLiteral = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "HexInteger":
      console.log("a HexInteger " + child.getText());
      break;
    case "OctalInteger":
      console.log("an OctalInteger " + child.getText());
      break;
    case "DecimalInteger":
      console.log("a DecimalInteger " + child.getText());
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// StringLiteral = ('"', { ANY - ('"' | '\') | EscapedChar }, '"') | ("'", { ANY - ("'" | '\') | EscapedChar }, "'") ;
var stringLiteral = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "EscapedChar":
      console.log("an EscapedChar");
      escapedChar(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// EscapedChar = '\', ('\' | "'" | '"' | (B) | (F) | (N) | (R) | (T) | ((U), 4 * HexDigit) | ((U), 8 * HexDigit)) ;
var escapedChar = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "HexDigit":
      console.log("an HexDigit");
      //hexDigit(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// Parameter = '$', (SymbolicName | DecimalInteger) ;
var parameter = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_SymbolicName":
      console.log("an oC_SymbolicName");
      //symbolicName(child);
      break;
    case "oC_DecimalInteger":
      console.log("an oC_DecimalInteger");
      //decimalInteger(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

/*
SymbolicName = UnescapedSymbolicName
             | EscapedSymbolicName
             | HexLetter
             | (C,O,U,N,T)
             | (F,I,L,T,E,R)
             | (E,X,T,R,A,C,T)
             | (A,N,Y)
             | (N,O,N,E)
             | (S,I,N,G,L,E)
             ;
*/
var symbolicName = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "UnescapedSymbolicName": // a symbol
      console.log("an UnescapedSymbolicName");
      unescapedSymbolicName(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// UnescapedSymbolicName = IdentifierStart, { IdentifierPart } ;
var unescapedSymbolicName = function(node) {
  // this type of node does not have children
  console.log(node.getText());
  xmlStrCSH += '<Hello roleName="' + node.getText() + '"/>\n';
  /*
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "IdentifierStart": // a symbol
      console.log("an IdentifierStart");
      identifierStart(child);
      break;
    case "IdentifierPart": // a symbol
      console.log("an IdentifierPart");
      identifierPart(child);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }*/
}

// IdentifierStart = ID_Start | Pc ;
// this is a low-level token that may never occur as a named thing
var identifierStart = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_ID_Start":
      console.log("an oC_ID_Start");
      // any of 125,884 unicode code points
      //id_Start(child);
      console.log(child.children);
      break;
    case "ID_Start": // not sure if this is a rule or a symbol
      console.log("an ID_Start");
      // any of 125,884 unicode code points
      //id_Start(child);
      console.log(child.children);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// IdentifierPart = ID_Continue | Sc ;
// this is a low-level token that may never occur as a named thing
var identifierPart = function(node) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    var nodeType = getNodeType(child);
    switch (nodeType) {
    case "oC_ID_Continue": // not sure if this is a rule or a symbol
      console.log("an oC_ID_Continue");
      // any of 128,789 unicode Code Points
      //id_Continue(child);
      console.log(child.children);
      break;
    case null: break;
    default: console.log("? " + nodeType); break;
    }
  }
}

// 

// 

var getNodeType = function(node) {
  console.log(node);
  //if (node.getPayload) {console.log(node.getPayload())};
  //if (node.getSymbol) {console.log(node.getSymbol())};
  //if (node.getText) {console.log(node.getText())};
  //console.log(node.toString());
  var nodeType = ruleNames[node.ruleIndex];
  if (nodeType) {
    console.log("RULE " + nodeType);
  }
  else {
    if (node.symbol) {
      nodeType = symbolicNames[node.symbol.type];
      if (nodeType) {
        console.log("SYMBOL " + nodeType);
      }
      else {
        console.log("LITERAL " + node.getText());
      }
    }
    else {
      console.log("NOT RULE|SYMBOL " + node.getText());
    }
  }
  if (!nodeType) {
    nodeType = null;
  }
  return nodeType;
}

// main
var antlr4 = require('xholon/lib/antlr4/index');
var CypherLexer = require('xholon/lib/antlr4g/CypherLexer');
var CypherParser = require('xholon/lib/antlr4g/CypherParser');
var CypherListener = require('xholon/lib/antlr4g/CypherListener');

var xmlStrIH = "<_-.XholonClass>\n  <TheSystem/>\n";
var xmlStrCD = "<xholonClassDetails>\n";
var xmlStrCSH = "<TheSystem>";

var nextActivityId = 1;
var actorClassContextName = null;
var transArr = null;
var seekingTopActor = false;

// behavior for one specific StateMachine, for an ActorClass with a Behavior
var beh = null;
//var bindings = {}; //[]; // cache all Binding(s) here
var actorRefObj = null;

var literalNames, ruleNames, symbolicNames;

document.getElementById("parse").addEventListener("click", function(){
  
  // testing
  //var input = document.getElementById("xhcypher").value;
  //var input = "CREATE (fgh {ijk: 'This is some text.'})"; // fails
  //var input = 'CREATE (fgh {ijk: "This is some text."})'; // fails
  //var input = 'CREATE (fgh {ijk: 123.4})'; // OK
  //var input = 'CREATE (fgh {ijk: ThisIsText})'; // OK, it sees ThisIsText as a symbol
  //var input = 'CREATE (fgh {ijk: `ThisIsText`})'; // fails
  //var input = "CREATE (fgh {ijk: \"This is some text.\"})"; // fails
  //var input = "CREATE (fgh {ijk: $This_is_some_text$})"; // use $ as a quote mark; it sees this as a Parameter
  var input = "CREATE (fgh {ijk: _This_is_some_text_})"; // use _ as a quote mark and as a space; it sees this as a UnescapedSymbolicName
  
  console.log(input);
  var chars = new antlr4.InputStream(input);
  console.log(chars);
  var lexer = new CypherLexer.CypherLexer(chars);
  var tokens  = new antlr4.CommonTokenStream(lexer);
  console.log(tokens);
  var parser = new CypherParser.CypherParser(tokens);
  parser.buildParseTrees = true; // default is true
  console.log(parser);
  var tree = parser.oC_Cypher();
  console.log("Parsed: "+ tree);
  literalNames = parser.literalNames;
  ruleNames = parser.ruleNames;
  symbolicNames = parser.symbolicNames;
  updateTree(tree);
  //
  xmlStrIH += "</_-.XholonClass>\n";
  xmlStrCD += '\n'
    + '  <XholonClass xhType="XhtypePureContainer"/>\n'
    ;
  xmlStrCD += "</xholonClassDetails>\n";
  xmlStrCSH += "</TheSystem>\n";
  console.log(xmlStrIH);
  console.log(xmlStrCD);
  console.log(xmlStrCSH);
  //console.log(bindings);
  if (xh) {
    var rootIH = xh.app().first().next().next().first().next().first();
    console.log(rootIH);
    rootIH.append(xmlStrIH);
    rootIH.append(xmlStrCD);
    var rootCSH = xh.root();
    console.log(rootCSH);
    rootCSH.println(xmlStrCSH);
    rootCSH.append(xmlStrCSH);
  }
  if (beh) {
    // write out the last behavior
    console.log(beh);
  }
});

    </script>
    
    <!--<div id="tree"></div>-->
    
    <div id="xhfooter">
    <hr/>
    <div class="license"  style="font-size: 9px;"><p>Xholon GWT is a <a href="index.html">Xholon</a> project. Copyright (C) 2017 Ken Webb</p></div>
    <div class="aatt" style="font-size: 9px;"><pre style="font-size: 9px;">
  @QWERTYUIk
  OPASmDFGHe
  primordion
  JKLZcXCVB.
    </pre></div>

  </body>
  
</html>
