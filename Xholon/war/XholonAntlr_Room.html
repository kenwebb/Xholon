<!doctype html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="author" content="Ken Webb" />
    <meta name="copyright" content="MIT License, Copyright (C) 2017 Ken Webb" />
    <!--<link rel="stylesheet" type="text/css" href="css/style.css">-->
    <script src="xholon/lib/antlr4-require.js"></script>
    <style>
    pre.antlr {
      border-style: solid;
      border-width: 1px;
      background-color: aliceblue;
    }
    #tree {
        margin-left: 50px;
        float:left;
        clear:right;
    }
    #inputs {
        float:left;
        clear:left;
    }
    .roomElement {
        background: beige;
        /*display: inline-block;*/
        padding: 5px;
        border-radius: 12px;
        border: 1px solid black;
        margin: 10px;
    }
    </style>
    <title>Xholon ANTLR - ROOM eTrice</title>
  </head>
  
  <body>
    <h3>Xholon ANTLR - ROOM eTrice</h3>
    
    <!-- http://127.0.0.1:8888/XholonAntlr_Room.html?app=HelloWorld&gui=clsc -->
    <p>This is an <a href="">eTrice ROOM</a> model.</p>
    <pre class="antlr">
ROOM grammar
    </pre>
    
    <div id="inputs">
      <textarea id="code">
RoomModel TemplateModel {

  /*
  This is a sample eTRice ROOM model.
  */
  
  // the import lines will be ignored
  import room.basic.types.* from "../../org.eclipse.etrice.modellib.java/model/Types.room"
  import room.basic.service.timing.* from "../../org.eclipse.etrice.modellib.java/model/TimingService.room"
  
  LogicalSystem LogSys {
    SubSystemRef subSystemRef: SubSysClass
  }

  SubSystemClass SubSysClass {
    ActorRef topActor: TopActor
    ActorRef timingService: ATimingService
    LayerConnection ref topActor satisfied_by timingServicetimer
    LogicalThread defaultThread
  }

  // - build your application from here
  ActorClass TopActor {
    Structure {
      ActorRef txr: Sender
      ActorRef rxr: Receiver
      ActorRef rxr2: Receiver
      ActorRef four: Four
    }
    Behavior {
      StateMachine {
        Transition init: initial -> ready {
          action {
        //    "$wnd.console.log('testing State Machine 1')"
          }
        }
        State ready
      }
    }
  }
  
  ProtocolClass PingPongProtocol {
    incoming {
      Message ping()
    }
    outgoing {
      Message pong()
    }
  }

  ActorClass Sender {
    Interface {
    }
    Structure {
    }
    Behavior {
      StateMachine {
      }
    }
  }

  ActorClass Receiver {
    Interface {
    }
    Structure {
    }
    Behavior {
      StateMachine {
      }
    }
  }
  
  ActorClass One {}
  ActorClass Two extends One {}
  ActorClass Three extends One {}
  
  ActorClass Four extends One {
    Structure {
      ActorRef two: Two
      ActorRef three: Three
    }
  }

}
</textarea>
      <br/>
      <button id="parse">Parse</button>
    </div>
    
    <script type="text/javascript">
var updateTree = function(tree, ruleNames) {
  var container = document.getElementById("tree");
  while (container.hasChildNodes()) {
    container.removeChild(container.lastChild);
  }
  for (var i = 0; i < tree.children.length; i++) {
    var child = tree.children[i];
    var nodeType = ruleNames[child.ruleIndex];
    console.log(nodeType);
    switch (nodeType) {
    case "subSystemClass":
      break;
    case "actorClass":
      var newElement = document.createElement("div");
      newElement.className = "roomElement";
      var superClassName = "";
      if ((child.children.length > 3) && (child.children[2].getText() == "extends")) {
        superClassName = ' superClass="' + child.children[3].getText() + '"';
      }
      var xmlIhStr = "<" + child.children[1].getText() + superClassName + "/>";
      xmlStrIH += "  " + xmlIhStr + "\n";
      xmlStrCSH += "  " + "<" + child.children[1].getText() + ">\n";
      for (var j = 0; j < child.children.length; j++) {
        console.log("" + j + " " + child.children[j].getText());
        recurseChild(child.children[j], ruleNames, "  ");
      }
      xmlStrCSH += "  " + "</" + child.children[1].getText() + ">\n";
      var newElementText = document.createTextNode(xmlIhStr);
      newElement.appendChild(newElementText);
      container.appendChild(newElement);
      break;
    default:
      break;
    } // end switch
  }
};

var recurseChild = function(child, ruleNames, indent) {
  if (!child) {return;}
  var nodeType = ruleNames[child.ruleIndex];
  console.log(nodeType);
  switch (nodeType) {
  case "structure":
    console.log("THIS IS A structure");
    break;
  case "behavior":
    console.log("THIS IS A behavior");
    //recurseBehavior(child.children[2], ruleNames);
    //return;
    break;
  case "actorRef":
    // ActorReftxr:Sender
    var xhcName = child.children[2].getText();
    var roleName = child.children[1].getText();
    roleName = roleName.substring(0, roleName.length-1); // remove trailing ":"
    var xmlCshStr = '<' + xhcName + ' roleName="' + roleName + '"/>';
    console.log(xmlCshStr);
    xmlStrCSH += indent + xmlCshStr + "\n";
    return;
  case "stateMachine":
    stateMachine(child, ruleNames, indent);
    return;
  case "transition":
    transition(child, ruleNames, indent);
    return;
  case "sstate":
    sstate(child, ruleNames, indent);
    return;
  case "subgraph":
    //subgraph(child, ruleNames, indent);
    //return;
    break;
  case "entry":
    entry(child, ruleNames, indent);
    return;
  case "exit":
    exit(child, ruleNames, indent);
    return;
  case "action":
    action(child, ruleNames, indent);
    return;
  case "trigger":
    trigger(child, ruleNames, indent);
    return;
  case "entryPoint":
    entryPoint(child, ruleNames, indent);
    return;
  case "exitPoint":
    exitPoint(child, ruleNames, indent);
    return;
  case "code":
    code(child, ruleNames, indent);
    return;
  default:
    break;
  }
  if (child.children) {
    for (var j = 0; j < child.children.length; j++) {
      console.log("" + j + " " + child.children[j].getText());
      recurseChild(child.children[j], ruleNames, indent + "  ");
    }
  }
}

var stateMachine = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<StateMachine>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</StateMachine>\n";
}

var transition = function(node, ruleNames, indent) {
  var roleName = node.children[1].getText();
  roleName = roleName.substring(0, roleName.length-1); // remove trailing ":"
  xmlStrCSH += indent + '<TransitionExternal roleName="' + roleName + '">\n';
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</TransitionExternal>\n";
}

var sstate = function(node, ruleNames, indent) {
  xmlStrCSH += indent + '<State roleName="' + node.children[1].getText() + '">\n';
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</State>\n";
}

/*var subgraph = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<StateMachine>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      //console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames);
    }
  }  
  xmlStrCSH += indent + "</StateMachine>\n";
}*/

var entry = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<ENTRY>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</ENTRY>\n";
}

var exit = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<EXIT>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</EXIT>\n";
}

var action = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<ACTION>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</ACTION>\n";
}

var trigger = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<Trigger>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</Trigger>\n";
}

var entryPoint = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<ENTRYPOINT>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</ENTRYPOINT>\n";
}

var exitPoint = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<EXITPOINT>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</EXITPOINT>\n";
}

var code = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<CODE>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</CODE>\n";
}

var antlr4 = require('xholon/lib/antlr4/index');
var RoomLexer = require('xholon/lib/antlr4g/RoomLexer');
var RoomParser = require('xholon/lib/antlr4g/RoomParser');
var RoomListener = require('xholon/lib/antlr4g/RoomListener');

var xmlStrIH = "<_-.XholonClass>\n";
var xmlStrCSH = "<_-.csh>\n";

document.getElementById("parse").addEventListener("click", function(){
  var input = document.getElementById("code").value;
  var chars = new antlr4.InputStream(input);
  var lexer = new RoomLexer.RoomLexer(chars);
  var tokens  = new antlr4.CommonTokenStream(lexer);
  var parser = new RoomParser.RoomParser(tokens);
  parser.buildParseTrees = true;
  var tree = parser.roomModel(); //.elements();
  console.log("Parsed: "+ tree);
  updateTree(tree, parser.ruleNames);
  //
  xmlStrIH += "</_-.XholonClass>\n";
  xmlStrCSH += "</_-.csh>\n";
  console.log(xmlStrIH);
  console.log(xmlStrCSH);
  //
  var printer = new RoomPrinter();
  antlr4.tree.ParseTreeWalker.DEFAULT.walk(printer, tree);
});

RoomPrinter = function() {
  RoomListener.RoomListener.call(this); // inherit default listener
  return this;
}

RoomPrinter.prototype = Object.create(RoomListener.RoomListener.prototype);
RoomPrinter.prototype.constructor = RoomPrinter;
RoomPrinter.prototype.enterRoomModel = function(ctx) {
  console.log("Entered RoomModel " + ctx.toStringTree());
  //console.log(ctx.children[2].getText());
  console.log(ctx);
};
    </script>
    
    <div id="tree"></div>
    
    <hr/>
    <div class="license"  style="font-size: 9px;"><p>Xholon GWT is a <a href="index.html">Xholon</a> project. Copyright (C) 2017 Ken Webb</p></div>
    <div class="aatt" style="font-size: 9px;"><pre style="font-size: 9px;">
  @QWERTYUIk
  OPASmDFGHe
  primordion
  JKLZcXCVB.
    </pre></div>

  </body>
  
</html>
