<!doctype html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="author" content="Ken Webb" />
    <meta name="copyright" content="MIT License, Copyright (C) 2017 Ken Webb" />
    <!--<link rel="stylesheet" type="text/css" href="css/style.css">-->
    <script src="xholon/lib/antlr4-require.js"></script>
    <style>
    pre.antlr {
      border-style: solid;
      border-width: 1px;
      background-color: aliceblue;
    }
    #tree {
        margin-left: 50px;
        float:left;
        clear:right;
    }
    #inputs {
        float:left;
        clear:left;
    }
    .roomElement {
        background: beige;
        /*display: inline-block;*/
        padding: 5px;
        border-radius: 12px;
        border: 1px solid black;
        margin: 10px;
    }
    </style>
    <title>Xholon ANTLR - ROOM eTrice</title>
  </head>
  
  <body>
    <h3>Xholon ANTLR - ROOM eTrice</h3>
    
    <!-- http://127.0.0.1:8888/XholonAntlr_Room.html?app=HelloWorld&gui=clsc -->
    <p>This is an <a href="">eTrice ROOM</a> model.</p>
    <pre class="antlr">
ROOM grammar
    </pre>
    
    <div id="inputs">
      <textarea id="code">
RoomModel TemplateModel {

  /*
  This is a sample eTRice ROOM model.
  */
  
  // the import lines will be ignored
  import room.basic.types.* from "../../org.eclipse.etrice.modellib.java/model/Types.room"
  import room.basic.service.timing.* from "../../org.eclipse.etrice.modellib.java/model/TimingService.room"
  
  LogicalSystem LogSys {
    SubSystemRef subSystemRef: SubSysClass
  }

  SubSystemClass SubSysClass {
    ActorRef topActor: TopActor
    ActorRef timingService: ATimingService
    LayerConnection ref topActor satisfied_by timingServicetimer
    LogicalThread defaultThread
  }

  // - build your application from here
  ActorClass TopActor {
    Structure {
      ActorRef txr: Sender
      ActorRef rxr: Receiver
      ActorRef rxr2: Receiver
      ActorRef four: Four
    }
    Behavior {
      StateMachine {
        Transition init: initial -> ready {
          action {
        //    "$wnd.console.log('testing State Machine 1')"
          }
        }
        State ready
      }
    }
  }
  
  ProtocolClass PingPongProtocol {
    incoming {
      Message ping()
    }
    outgoing {
      Message pong()
    }
  }

  ActorClass Sender {
    Interface {
    }
    Structure {
    }
    Behavior {
      StateMachine {
      }
    }
  }

  ActorClass Receiver {
    Interface {
    }
    Structure {
    }
    Behavior {
      StateMachine {
      }
    }
  }
  
  ActorClass One {}
  ActorClass Two extends One {}
  ActorClass Three extends One {}
  
  ActorClass Four extends One {
    Structure {
      ActorRef two: Two
      ActorRef three: Three
    }
  }

}
</textarea>
      <br/>
      <button id="parse">Parse</button>
    </div>
    
    <script type="text/javascript">
var updateTree = function(tree, ruleNames) {
  var container = document.getElementById("tree");
  while (container.hasChildNodes()) {
    container.removeChild(container.lastChild);
  }
  for (var i = 0; i < tree.children.length; i++) {
    var child = tree.children[i];
    var nodeType = ruleNames[child.ruleIndex];
    console.log(nodeType);
    switch (nodeType) {
    case "subSystemClass":
      break;
    case "actorClass":
      actorClassContextName = child.children[1].getText();
      var newElement = document.createElement("div");
      newElement.className = "roomElement";
      var superClassName = "";
      if ((child.children.length > 3) && (child.children[2].getText() == "extends")) {
        superClassName = ' superClass="' + child.children[3].getText() + '"';
      }
      var xmlIhStr = "<" + actorClassContextName + superClassName + "/>";
      xmlStrIH += "  " + xmlIhStr + "\n";
      xmlStrCSH += "  " + "<" + actorClassContextName + ">\n";
      for (var j = 0; j < child.children.length; j++) {
        console.log("" + j + " " + child.children[j].getText());
        recurseChild(child.children[j], ruleNames, "  ");
      }
      xmlStrCSH += "  " + "</" + actorClassContextName + ">\n";
      var newElementText = document.createTextNode(xmlIhStr);
      newElement.appendChild(newElementText);
      container.appendChild(newElement);
      break;
    default:
      break;
    } // end switch
  }
};

var recurseChild = function(child, ruleNames, indent) {
  if (!child) {return;}
  var nodeType = ruleNames[child.ruleIndex];
  console.log(nodeType);
  switch (nodeType) {
  case "structure":
    console.log("THIS IS A structure");
    break;
  case "behavior":
    behavior(child, ruleNames, indent);
    return;
  case "actorRef":
    // ActorReftxr:Sender
    var xhcName = child.children[2].getText();
    var roleName = child.children[1].getText();
    roleName = roleName.substring(0, roleName.length-1); // remove trailing ":"
    var xmlCshStr = '<' + xhcName + ' roleName="' + roleName + '"/>';
    console.log(xmlCshStr);
    xmlStrCSH += indent + xmlCshStr + "\n";
    return;
  case "stateMachine":
    stateMachine(child, ruleNames, indent);
    return;
  case "transition":
    transition(child, ruleNames, indent);
    return;
  case "sstate":
    sstate(child, ruleNames, indent);
    return;
  case "subgraph":
    subgraph(child, ruleNames, indent);
    return;
  case "entry":
    entry(child, ruleNames, indent);
    return;
  case "exit":
    exit(child, ruleNames, indent);
    return;
  case "action":
    action(child, ruleNames, indent);
    return;
  case "trigger":
    trigger(child, ruleNames, indent);
    return;
  case "entryPoint":
    entryPoint(child, ruleNames, indent);
    return;
  case "exitPoint":
    exitPoint(child, ruleNames, indent);
    return;
  case "code":
    code(child, ruleNames, indent);
    return;
  default:
    break;
  }
  if (child.children) {
    for (var j = 0; j < child.children.length; j++) {
      console.log("" + j + " " + child.children[j].getText());
      recurseChild(child.children[j], ruleNames, indent + "  ");
    }
  }
}

var behavior = function(node, ruleNames, indent) {
  if (beh) {
    // write out the previous behavior
    console.log(beh);
  }
  console.log("THIS IS A new behavior");
  var cnodeParentName = actorClassContextName; //node.parentCtx.children[1].getText(); // xmlName
  var jsName = cnodeParentName.charAt(0).toLowerCase() + cnodeParentName.substring(1);
  beh = '<' + cnodeParentName + 'behavior implName="org.primordion.xholon.base.Behavior_gwtjs"><![CDATA[\n' // ex: Turnstilebehavior
    + "var " + jsName + ";\n" // ex: turnstile
    + "var beh = {\n"
    + "  postConfigure: function() {\n"
    + "    " + jsName + " = this.cnode.parent();\n"
    + "  },\n"
    + "  processReceivedMessage: function(msg) {\n"
    + "    if (" + jsName + ".first()) {\n"
    + "      " + jsName + ".first().call(msg.signal, msg.data, msg.sender);\n"
    + "    }\n"
    + "  },\n"
    + "  performActivity: function(activityId, msg) {\n"
    + "    switch (activityId) {\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "    ");
    }
  }
  beh += "    default:\n"
    + "      break;\n"
    + "    }\n" // end of switch
    + "  }\n" // end of performActivity
    + "}\n" // end of beh
    + "]]></" + cnodeParentName + "behavior>\n" // ex: Turnstilebehavior
    ;
}

var stateMachine = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<StateMachine>\n";
  xmlStrCSH += indent + '  <State roleName="Top">\n';
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "    ");
    }
  }
  xmlStrCSH += indent + '  </State>\n';
  xmlStrCSH += indent + "</StateMachine>\n";
}

var transition = function(node, ruleNames, indent) {
  var roleName = node.children[1].getText();
  var sourceStateName = node.children[2].getText();
  var targetStateName = node.children[4].getText();
  roleName = roleName.substring(0, roleName.length-1); // remove trailing ":"
  if (sourceStateName == "initial") {
    xmlStrCSH += indent + "<PseudostateInitial>\n";
  }
  xmlStrCSH += indent + '<TransitionExternal roleName="' + roleName + '">\n';
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }
  xmlStrCSH += indent + '  <Target roleName="' + targetStateName + '"\>\n';
  xmlStrCSH += indent + "</TransitionExternal>\n";
  if (sourceStateName == "initial") {
    xmlStrCSH += indent + "</PseudostateInitial>\n";
  }
}

var sstate = function(node, ruleNames, indent) {
  xmlStrCSH += indent + '<State roleName="' + node.children[1].getText() + '">\n';
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</State>\n";
}

var subgraph = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<Region>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</Region>\n";
}

var entry = function(node, ruleNames, indent) {
  xmlStrCSH += indent + '<EntryActivity roleName="' + nextActivityId + '">\n';
  beh += "    case " + nextActivityId + ":\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }
  beh += "      break;\n";
  xmlStrCSH += indent + "</EntryActivity>\n";
  nextActivityId++;
}

var exit = function(node, ruleNames, indent) {
  xmlStrCSH += indent + '<ExitActivity roleName="' + nextActivityId + '">\n';
  beh += "    case " + nextActivityId + ":\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  beh += "      break;\n";
  xmlStrCSH += indent + "</ExitActivity>\n";
  nextActivityId++;
}

var action = function(node, ruleNames, indent) {
  xmlStrCSH += indent + '<Activity roleName="' + nextActivityId + '">\n';
  // write a "case" to the current "<...behavior>"
  beh += "    case " + nextActivityId + ": // TODO put name of source state here\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }
  beh += "      break;\n";
  xmlStrCSH += indent + '</Activity>\n';
  nextActivityId++;
}

var trigger = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<Trigger>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</Trigger>\n";
}

var entryPoint = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<ENTRYPOINT>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</ENTRYPOINT>\n";
}

var exitPoint = function(node, ruleNames, indent) {
  xmlStrCSH += indent + "<EXITPOINT>\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  xmlStrCSH += indent + "</EXITPOINT>\n";
}

var code = function(node, ruleNames, indent) {
  //xmlStrCSH += indent + "<CODE>\n";
  var cnodeParentName = actorClassContextName; //node.parentCtx.children[1].getText(); // xmlName
  var jsName = cnodeParentName.charAt(0).toLowerCase() + cnodeParentName.substring(1);
  beh += "      " + jsName + ".println(" + node.children[0] +  ");\n";
  if (node.children) {
    for (var j = 0; j < node.children.length; j++) {
      console.log("" + j + " " + node.children[j].getText());
      recurseChild(node.children[j], ruleNames, indent + "  ");
    }
  }  
  //xmlStrCSH += indent + "</CODE>\n";
}

var antlr4 = require('xholon/lib/antlr4/index');
var RoomLexer = require('xholon/lib/antlr4g/RoomLexer');
var RoomParser = require('xholon/lib/antlr4g/RoomParser');
var RoomListener = require('xholon/lib/antlr4g/RoomListener');

var xmlStrIH = "<_-.XholonClass>\n";
var xmlStrCSH = "<_-.csh>\n";

var nextActivityId = 1;
var actorClassContextName = null;

// behavior for one specific StateMachine, for an ActorClass with a Behavior
var beh = null;

document.getElementById("parse").addEventListener("click", function(){
  var input = document.getElementById("code").value;
  var chars = new antlr4.InputStream(input);
  var lexer = new RoomLexer.RoomLexer(chars);
  var tokens  = new antlr4.CommonTokenStream(lexer);
  var parser = new RoomParser.RoomParser(tokens);
  parser.buildParseTrees = true;
  var tree = parser.roomModel(); //.elements();
  console.log("Parsed: "+ tree);
  updateTree(tree, parser.ruleNames);
  //
  xmlStrIH += "</_-.XholonClass>\n";
  xmlStrCSH += "</_-.csh>\n";
  console.log(xmlStrIH);
  console.log(xmlStrCSH);
  if (beh) {
    // write out the last behavior
    console.log(beh);
  }

  //
  var printer = new RoomPrinter();
  antlr4.tree.ParseTreeWalker.DEFAULT.walk(printer, tree);
});

RoomPrinter = function() {
  RoomListener.RoomListener.call(this); // inherit default listener
  return this;
}

RoomPrinter.prototype = Object.create(RoomListener.RoomListener.prototype);
RoomPrinter.prototype.constructor = RoomPrinter;
RoomPrinter.prototype.enterRoomModel = function(ctx) {
  console.log("Entered RoomModel " + ctx.toStringTree());
  //console.log(ctx.children[2].getText());
  console.log(ctx);
};
    </script>
    
    <div id="tree"></div>
    
    <hr/>
    <div class="license"  style="font-size: 9px;"><p>Xholon GWT is a <a href="index.html">Xholon</a> project. Copyright (C) 2017 Ken Webb</p></div>
    <div class="aatt" style="font-size: 9px;"><pre style="font-size: 9px;">
  @QWERTYUIk
  OPASmDFGHe
  primordion
  JKLZcXCVB.
    </pre></div>

  </body>
  
</html>
