<?xml version="1.0" encoding="UTF-8"?>
<!--
Experiment where two agents, each on its own island, initially fish only for different Fish species.
So there is no (or very minimal) interaction or exploitation.

see TestTool in Island game
  "use TestTool to test the Avatar apply command; TestTool has to be a GWT behavior"
see Subtrees workbook  c12c030f739cf8127313b6dbe920aa50

To use this module in the Island game:
 - drag the entire contents into the current location (ex: CoastCell) of the system avatar
 - result: a bordered space in the Ocean, with two small islands, 2 Avatars, and 2 types of fish in the Ocean
-->
<XholonModule>
  <XholonMap>
  
    <Attribute_String roleName="ih"><![CDATA[
<_-.XholonClass>
  <!-- two types of fish, distinguished by color -->
  <PinkFish superClass="Fish"/>
  <OrangeFish superClass="Fish"/>
  <!-- two types of Avatar, distinguished by color -->
  <PinkAvatar superClass="Avatar"/>
  <OrangeAvatar superClass="Avatar"/>
  <HandleFish superClass="Script"/>
  <FishCounter superClass="Script"/>
</_-.XholonClass>
    ]]></Attribute_String>
    
    <!-- Fish symbols and colors; behaviors -->
    <Attribute_String roleName="cd"><![CDATA[
<xholonClassDetails>
  <PinkFish><Symbol>LRTriangle</Symbol><Color>pink</Color></PinkFish>
  <OrangeFish><Symbol>LRTriangle</Symbol><Color>orange</Color></OrangeFish>
  <PinkAvatar><Color>pink</Color></PinkAvatar>
  <OrangeAvatar><Color>orange</Color></OrangeAvatar>
  
  <HandleFish><DefaultContent>
var me, ava, avaColor, beh = {
postConfigure: function() {
  me = this.cnode;
  ava = me.parent().parent();
  var xhcName = ava.xhc().name();
  avaColor = xhcName.substring(0, xhcName.indexOf("Avatar")); // should be "Pink" or "Orange"
  if (!ava["subtrees"]) {
    ava.action("param subtrees true");
  }
},
act: function() {
  var maybeFish = ava.next();
  if (maybeFish &amp;&amp; (maybeFish.xhc().name().startsWith(avaColor))) {
    //ava.println(ava.name() + " wants to eat " + maybeFish.name() + ". Can't wait!");
    ava.action("take " + maybeFish.name());
  }
}
}
//# sourceURL=HandleFishbehavior.js
  </DefaultContent></HandleFish>
  
  <FishCounter><DefaultContent>
$wnd.console.log("FishCounter ...");
const xpos = 5;
const ypos = 5;
var me, space, oceanCellStartArr, beh = {
postConfigure: function() {
  $wnd.console.log("FishCounter is alive ...");
  me = this.cnode;
  $wnd.xh.root().append(me.remove());
  me.println(me.name());
  me.println(me.parent().name());
  space = $wnd.xh.root().xpath("descendant::Space");
  me.println(space);
  me.println(space.name());
  //me.println(me.xpos); // null
  me.println(xpos);
  oceanCellStartArr = [];
  var row = space.xpath("*[" + (ypos + 2) + "]");
  var cell = row.xpath("*[" + (xpos + 2) + "]");
  me.println(row);
  me.println(cell);
  while (cell) {
    if (cell.xhc().name() != "OceanCell") {break;}
    oceanCellStartArr.push(cell);
    cell = cell.port(2);
  }
  me.println(oceanCellStartArr.length);
  $wnd.console.log(oceanCellStartArr);
  me.println("PinkFish,OrangeFish");
},
act: function() {
  var pinkCount = 0;
  var orangeCount = 0;
  for (var i = 0; i &lt; oceanCellStartArr.length; i++) {
    var cell = oceanCellStartArr[i];
    while (cell &amp;&amp; cell.xhc().name() != "LandCell") {
      var maybefish = cell.first();
      while (maybefish) {
        switch (maybefish.xhc().name()) {
        case "PinkFish": pinkCount++; break;
        case "OrangeFish": orangeCount++; break;
        default: break;
        }
        maybefish = maybefish.next();
      }
      cell = cell.next();
    }
  }
  me.println(pinkCount + "," + orangeCount);
}
}
//# sourceURL=FishCounterbehavior.js
  </DefaultContent></FishCounter>

</xholonClassDetails>
    ]]></Attribute_String>
    
    <Attribute_String roleName="csh"><![CDATA[
<_-.csh>

<!--<FishCounter/>-->

<GridCellPatterns>
  <!-- Currently it only works if I include a border of "." nodes, probably because the bigger the grid the morre likely it is that more distant fish will initially move into the grid. TODO fix this -->
  <GridCellPattern roleName="Isle x" xpos="5" ypos="5" islandID="0">
.......................
.LLLLLLLLLLLLLLLLLLLLL.
.L...................L.
.L.KC................L.
.L...................L.
.L...................L.
.L...................L.
.L...................L.
.L...................L.
.L...................L.
.L...................L.
.L.........F.........L.
.L...................L.
.L...................L.
.L...................L.
.L...................L.
.L...................L.
.L...................L.
.L...................L.
.L................CK.L.
.L...................L.
.LLLLLLLLLLLLLLLLLLLLL.
.......................
  </GridCellPattern>
  <!--<GridCellPattern roleName="Isle x" xpos="10" ypos="10" islandID="0">
LLLLLLLLLL
L........L
L.KC.....L
L........L
L........L
L........L
L........L
L.....CK.L
L........L
LLLLLLLLLL
  </GridCellPattern>-->
  <!--<GridCellPattern roleName="Isle x" xpos="5" ypos="5" islandID="0">
LLLLLLLLLLLL
L..........L
L.KC.......L
L..........L
L..........L
L..........L
L..........L
L..........L
L..........L
L..........L
L..........L
L..........L
L..........L
L..........L
L..........L
L..........L
L..........L
L.......CK.L
L..........L
LLLLLLLLLLLL
  </GridCellPattern>-->
  
  <GridCellPatternbehavior implName="org.primordion.xholon.base.Behavior_gwtjs">
const colorArr = ["Pink", "Orange"];
const NUM_FISH = 100; // number of fish of each color to create
var me, colorArrIx, beh = {
postConfigure: function() {
  me = this.cnode.parent(); // GridCellPatterns node
  colorArrIx = 0;
  //me.println(me.name());
  var gcp = me.first(); // GridCellPattern node
  //me.println(gcp.name());
  this.cnode.remove();
  //me.println("xpos:" + gcp.xpos + " ypos:" + gcp.ypos);
  var gcpstr = gcp.text().trim();
  var gcparr = gcpstr.split("\n");
  var row = me.xpath("../../../FieldRow[" + gcp.ypos + "]");
  var fcol = row.xpath("OceanCell[" + gcp.xpos + "]");
  var col = fcol;
  for (var i = 0; i &lt; gcparr.length; i++) {
    var gcpline = gcparr[i].trim();
    for (var j = 0; j &lt; gcpline.length; j++) {
      col["incognita"] = null;
      // remove any pre-existing fish or other objects inside the current cell/column
      var item = col.first();
      while (item) {
        var nextItem = item.next();
        me.println("removing item: " + item.name());
        item.remove();
        item = nextItem;
      }
      switch (gcpline[j]) {
      case "L":
        col.xhc("LandCell");
        break;
      case "C":
        col.xhc("CoastCell");
        break;
      case "K": // CoastCell + Avatar + fish
        col.xhc("CoastCell");
        // A v a t a r
        col.append('&lt;' + colorArr[colorArrIx] + 'Avatar>'
        + '&lt;BehaviorsST>'
        + '&lt;HandleFish/>'
        + '&lt;/BehaviorsST>'
        + '&lt;/' + colorArr[colorArrIx] + 'Avatar>'
        + '');
        col.last().action("param transcript false"); // prevent Avatar from writing messages
        colorArrIx++;
        break;
      case "F": // fish go here
        // f i s h
        var fishXmlStr = '&lt;_-.fish>';
        for (var fix = 0; fix &lt; colorArr.length; fix++) {
          fishXmlStr += '&lt;' + colorArr[fix] + 'Fish multiplicity="' + NUM_FISH + '">'
          + '&lt;Fishbehavior implName="org.primordion.xholon.base.Behavior_gwtjs">'
          + 'var beh = new $wnd.xh.FishMovebehavior();'
          + '&lt;/Fishbehavior>'
          + '&lt;/' + colorArr[fix] + 'Fish>';
        }
        fishXmlStr += '&lt;/_-.fish>';
        //me.println(fishXmlStr);
        col.append(fishXmlStr);
        break;
      default: // "."
        break;
      }
      col = col.next();
    }
    fcol = fcol.port(2);
    col = fcol;
  }
  me.remove();
}
}
//# sourceURL=GridCellPatternbehavior2.js
</GridCellPatternbehavior>

</GridCellPatterns>

</_-.csh>
    ]]></Attribute_String>
    
  </XholonMap>
</XholonModule>
